<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>辞辞不吃糖</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-29T03:05:10.230Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>辞辞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最大子序和</title>
    <link href="http://example.com/2024/11/29/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://example.com/2024/11/29/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2024-11-29T02:16:07.000Z</published>
    <updated>2024-11-29T03:05:10.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给定一个整数数组<code>nums</code>，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例1</p><ul><li>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</li><li>输出：6</li><li>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</li></ul><p>示例2</p><ul><li>输入：nums = [1]</li><li>输出：1</li></ul><p>示例3<br />输入：nums = [5,4,-1,7,8]<br />输出：23</p><blockquote><p><a href="https://www.bilibili.com/video/BV1aY4y1Z7ya/">《代码随想录》算法公开课</a><br /><a href="https://leetcode.cn/problems/maximum-subarray/description/">力扣题目链接</a></p></blockquote><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><h2 id="暴力解法"><a class="markdownIt-Anchor" href="#暴力解法"></a> 暴力解法</h2><ul><li>暴力解法的思路，第一层<code>for</code>就是设置起始位置，第二层 <code>for</code>循环遍历数组寻找最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//先将结果设为最小整数，以便于后续结果做对比不被影响</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//单个子序列的总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//每次进行新一轮遍历时，都重置子序列和</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums,length; j++)&#123;</span><br><span class="line">                <span class="comment">//固定外层nums[i]移动j指针，寻找最大子序列和</span></span><br><span class="line">                count += nums[j];</span><br><span class="line">                <span class="comment">//当前子序列和大于res时，将其count值赋给res</span></span><br><span class="line">                res = count &gt; res ? count : res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：此方法的时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>，一般会超过题目给定的时间限制，提示超时错误</p></blockquote><h2 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h2><p>所谓贪心算法，就是在子序和为负数时，直接舍弃当前<code>count</code>，对其<code>count</code>进行重新赋值<code>0</code>的操作，因为负数只会拉低综合，这便是局部最优。</p><p><strong>从代码角度上来讲：遍历<code>nums</code>，从头开始用<code>count</code>累积，如果<code>count</code>一旦加上<code>nums[i]</code>变为负数，那么就应该从<code>nums[i+1]</code>开始从<code>0</code>累积<code>count</code>了，因为已经变为负数的<code>count</code>，只会拖累总和。</strong></p><ul><li><strong>注：这相当于是暴力解法中的不断调整最大子序和区间的起始位置。</strong></li></ul><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//当长度为1时直接返回其值便是最大子序和</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将返回值初始为整型最小值，以便后续赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="comment">//先对比取出最大值，再判断count是否&lt;0，这么做是为了防止最大值便是负数导致遗漏</span></span><br><span class="line">            max = Math.max(max, count); </span><br><span class="line">            <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                count = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;/a&gt; 题目&lt;/h1&gt;
&lt;p&gt;给定一个整数数组&lt;code&gt;nums&lt;/code&gt;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;示例</summary>
      
    
    
    
    <category term="贪心算法" scheme="http://example.com/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="贪心算法" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>摆动序列</title>
    <link href="http://example.com/2024/11/28/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2024/11/28/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</id>
    <published>2024-11-28T14:28:16.000Z</published>
    <updated>2024-11-28T15:32:13.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>例如，<code>[1,7,4,9,2,5]</code>是一个摆动序列，因为差值 <code>(6,-3,5,-7,3) </code>是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和<code>[1,7,4,5,5]</code>不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>示例1</p><ul><li>输入: [1,7,4,9,2,5]</li><li>输出: 6</li><li>解释: 整个序列均为摆动序列。</li></ul><p>示例2</p><ul><li>输入: [1,17,5,10,13,15,10,5,16,8]</li><li>输出: 7</li><li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>示例3</p><ul><li>输入: [1,2,3,4,5,6,7,8,9]</li><li>输出: 2</li></ul><p><a href="https://www.bilibili.com/video/BV17M411b7NS/">《代码随想录》算法公开课</a><br /><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">力扣题目链接</a></p><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><h2 id="题意分析"><a class="markdownIt-Anchor" href="#题意分析"></a> 题意分析</h2><blockquote><p>首先，题目需要的是摆动序列，即先将数列进行列出，如下图<br /><img src="/img/timu/376-1.jpg" alt="376摆动序列" title="摆动序列" /><br /><img src="/img/timu/376-2.jpg" alt="376-1摆动序列" title="摆动序列" /><br />摆动序列即数列列出的形状如同波浪线一般，在该题中我们可以删去某些元素再进行排序，由贪心算法的每次取局部最优，得到全局最优，我们每次都只取峰值元素，即当有片段单调递增或单调递减时，我们支取最高点或者最低点。<br />如示例2：<br /><img src="/img/timu/376-3.png" alt="376-2摆动序列" title="摆动序列" /></p><ul><li><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。</strong></li><li><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</strong></li></ul></blockquote><h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2><ol><li>上下坡中有平坡<br />例如：[1,2,2,2,1]<br /><img src="/img/timu/376-4.png" alt="摆动序列" title="摆动序列" /></li></ol><ul><li>当我们遇到平波时，相同的元素支取一次就行了，此时同一一下规则，删除左边的相同元素，即<code>(prediff &gt;= 0 &amp;&amp; curdiff &lt; 0 ) || (prediff &lt;= 0 &amp;&amp; curdiff &gt; 0)</code>。</li></ul><blockquote><p>注：<code>curdiff</code>为当前元素与前一元素的差值，<code>prediff</code>为前一元素与其前一元素的差值。</p></blockquote><ol start="2"><li>数组首尾两端</li></ol><ul><li>对于这种特殊情况我们可以定死规则，即当数组大小为2时，<code>nums[0] != nums[1]</code>即返回2</li></ul><ol start="3"><li>单调坡中有平坡<br />例如：[1,2,2,2,3,4]<br /><img src="/img/timu/376-5.png" alt="摆动序列" title="摆动序列" /></li></ol><ul><li>对于这种情况我们只需要规定<code>prediff</code>的更新时间即可，即当有坡度变化时才去更新<code>prediff</code>的值。</li></ul><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//长度为2，且元素不相等时，为摆动序列，直接返回2</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span> &amp;&amp; (nums[<span class="number">0</span>] != nums[<span class="number">1</span>]))<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//当前差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//上一个差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录返回值，即摆动序列长度，从索引1处开始，则至少有一个数满足题意</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//得到当前差值</span></span><br><span class="line">            curDiff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//如果当前差值和上一个差值为一正一负</span></span><br><span class="line">            <span class="comment">//等于0的情况表示初始时的preDiff</span></span><br><span class="line">            <span class="keyword">if</span> ((curDiff &gt; <span class="number">0</span> &amp;&amp; preDiff &lt;= <span class="number">0</span>) || (curDiff &lt; <span class="number">0</span> &amp;&amp; preDiff &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;/a&gt; 题目&lt;/h1&gt;
&lt;p&gt;如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列</summary>
      
    
    
    
    <category term="贪心算法" scheme="http://example.com/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="贪心算法" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法-分发饼干</title>
    <link href="http://example.com/2024/11/28/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <id>http://example.com/2024/11/28/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</id>
    <published>2024-11-28T04:46:02.000Z</published>
    <updated>2024-11-28T05:28:54.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是贪心算法"><a class="markdownIt-Anchor" href="#什么是贪心算法"></a> 什么是贪心算法</h1><ul><li>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</li><li>例如有一堆不同数额的钞票，每次只能拿一张，怎么拿能取得最大数额的钞票。<ul><li>方法：将钞票从大到小进行排序，每次都拿走当前堆里最大面额的钞票，即可在指定拿取次数中获得最大数额的钞票。</li><li>例如：[100, 100, 50, 20, 50, 1, 10]<ul><li>排序后为：[100, 100, 50, 50, 20, 10, 1]</li><li>依次取数组中的最大值进行累加</li><li>取完指定次数后，累加值即为最优解</li></ul></li><li>在这个过程中，每次取最大面额的钞票为<code>局部最优</code>，通过每次获得<code>局部最优</code>得到的结果即为<code>全局最优</code>。</li></ul></li></ul><blockquote><p>注意：贪心算法并没有固定套路，也没有固定策略，贪心算法有时候就是常识的推导，所以认为本应该这么做！</p></blockquote><h1 id="小题一道-分发饼干"><a class="markdownIt-Anchor" href="#小题一道-分发饼干"></a> 小题一道-分发饼干</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子<code>i</code>，都有一个胃口值<code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干<code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干<code>j</code> 分配给孩子<code>i</code>，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><blockquote><p>示例1</p><ul><li>输入: g = [1,2,3], s = [1,1]</li><li>输出: 1</li><li>解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。</li></ul></blockquote><blockquote><p>示例2</p><ul><li>输入: g = [1,2], s = [1,2,3]</li><li>输出: 2</li><li>解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.</li></ul></blockquote><p><a href="https://www.bilibili.com/video/BV1MM411b7cq/">《代码随想录》算法公开课</a></p><p><a href="https://leetcode.cn/problems/assign-cookies/description/">力扣题目链接</a></p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ul><li>首先，每个孩子只能获得一块饼干，大尺寸的饼干能满足对于饼干需求小于等于该尺寸的孩子</li><li>为了减少饼干的浪费，这里我们优先考虑将大尺寸的饼干给到胃口大的孩子</li><li>即此处的<code>局部最优</code>便是，将大尺寸的饼干分给胃口大的孩子，<code>全局最优</code>便是尽量喂饱更多孩子<br /><img src="/img/timu/455-1.png" alt="分发饼干-代码随想录" title="分发饼干" /></li></ul><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><h2 id="优先考虑胃口先喂饱大胃口的孩子"><a class="markdownIt-Anchor" href="#优先考虑胃口先喂饱大胃口的孩子"></a> 优先考虑胃口，先喂饱大胃口的孩子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//优先考虑胃口，先喂饱大胃口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);<span class="comment">//对两个数组进行升序排序</span></span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="comment">//count统计被喂饱的孩子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//饼干尺寸从大到小进行与孩子胃口匹配</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历胃口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> g.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="comment">//start &gt;= 0为了防止数组越界错误</span></span><br><span class="line">            <span class="comment">//当饼干尺寸满足孩子时，将饼干分给g[index],然后饼干向更小的尺寸移动，孩子也向胃口更小的移动，如果孩子胃口大于饼干尺寸，则无法满足该孩子，直接向胃口小的孩子移动</span></span><br><span class="line">            <span class="keyword">if</span>(start &gt;= <span class="number">0</span> &amp;&amp; g[index] &lt;= s[start]) &#123;</span><br><span class="line">                start--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先考虑饼干小饼干先喂饱小胃口"><a class="markdownIt-Anchor" href="#优先考虑饼干小饼干先喂饱小胃口"></a> 优先考虑饼干，小饼干先喂饱小胃口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length &amp;&amp; start &lt; g.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= g[start]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是贪心算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是贪心算法&quot;&gt;&lt;/a&gt; 什么是贪心算法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;贪心的本质是选择每一阶段的局部最优，从而达到全局最优。&lt;/li&gt;
&lt;li&gt;例如有一堆不同数额的钞票，每</summary>
      
    
    
    
    <category term="贪心算法" scheme="http://example.com/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="贪心算法" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>修剪二叉搜索树</title>
    <link href="http://example.com/2024/11/27/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://example.com/2024/11/27/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2024-11-27T05:42:05.000Z</published>
    <updated>2024-11-27T11:32:27.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给定一个二叉搜索树，同时给定最小边界<code>low</code>和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中<code>(high&gt;=low)</code> 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><blockquote><p>示例1</p><ul><li>输入：root = [1,0,2], low = 1, high = 2</li><li>输出：[1,null,2]<br /><img src="/img/timu/669-1.jpg" alt="修剪二叉树" title="修剪二叉搜索树" /></li></ul></blockquote><blockquote><p>示例2</p><ul><li>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</li><li>输出：[3,2,null,1]<br /><img src="/img/timu/669-2.jpg" alt="修剪二叉树" title="修剪二叉搜索树" /></li></ul></blockquote><p><a href="https://www.bilibili.com/video/BV17P41177ud/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f">《代码随想录》算法视频公开课</a></p><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">力扣题目链接</a></p><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><ul><li>题目所给二叉树为搜索二叉树</li><li>首先判断根结点是否在给定范围内，如果大于给定范围，则返回其根结点的左结点作为输出树的根结点，如果小于给定范围，则返回根结点的右结点作为根结点</li><li>记录当前根结点，先向左树进行遍历剪切</li><li>再次记录根结点，向右树进行遍历剪切</li></ul><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><h2 id="迭代法"><a class="markdownIt-Anchor" href="#迭代法"></a> 迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//首先对根结点进行判断--是否超越给定边界</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high))&#123;</span><br><span class="line">            <span class="comment">//小于则返回根结点的右结点作为边界</span></span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; low) root = root.right;</span><br><span class="line">            <span class="comment">//反则返回根结点的左结点</span></span><br><span class="line">            <span class="keyword">else</span> root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录当前根结点，用于下述的遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span>  <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//遍历左树，寻找是否有需要剪切的结点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.left != <span class="literal">null</span> &amp;&amp; cur.left.val &lt; low)&#123;</span><br><span class="line">                <span class="comment">//进行剪切操作，因为当cur.left.val小于边界时，其左子树全部小于，直接全切了，右树同样操作</span></span><br><span class="line">                cur.left = cur.left.right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.right != <span class="literal">null</span> &amp;&amp; cur.right.val &gt; high)&#123;</span><br><span class="line">                cur.right = cur.right.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;/a&gt; 题目&lt;/h1&gt;
&lt;p&gt;给定一个二叉搜索树，同时给定最小边界&lt;code&gt;low&lt;/code&gt;和最大边界 &lt;code&gt;high&lt;/code&gt;。通过修剪二叉搜索树，使得所有</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="搜索二叉树" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>删除二叉搜索树中的节点</title>
    <link href="http://example.com/2024/11/27/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2024/11/27/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2024-11-27T02:52:43.000Z</published>
    <updated>2024-11-27T04:59:30.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给定一个二叉搜索树的根节点<code>root</code>和一个值<code>key</code>，删除二叉搜索树中的<code>key</code>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p><a href="https://www.bilibili.com/video/BV1tP41177us/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f">《代码随想录》算法视频公开课</a></p><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">力扣题目链接</a></p><blockquote><p>示例1</p><ul><li>输入：root = [5,3,6,2,4,null,7], key = 3</li><li>输出：[5,4,6,2,null,null,7]</li><li>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它<br />图示<br /><img src="/img/timu/www.jpg" alt="删除二叉搜索树中的节点" title="力扣450-删除二叉搜索树中的节点" /><br />示例2</li><li>输入: root = [5,3,6,2,4,null,7], key = 0</li><li>输出: [5,3,6,2,4,null,7]</li><li>解释: 二叉树不包含值为 0 的节点<br />示例3</li><li>输入: root = [], key = 0</li><li>输出: []</li></ul></blockquote><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><h2 id="删除结点可能出现的五种情况"><a class="markdownIt-Anchor" href="#删除结点可能出现的五种情况"></a> 删除结点可能出现的五种情况</h2><ol><li>没有找到<code>key</code>对应结点：<ul><li>没找到删除的节点，遍历到空节点直接返回了</li></ul></li><li>找到<code>key</code>对应的结点：<ul><li><code>key</code>对应结点的左孩子为<code>null</code>，右孩子不为<code>null</code>，则直接返回右孩子</li><li><code>key</code>对应结点的右孩子为<code>null</code>，左孩子不为<code>null</code>，则直接返回左孩子</li><li>删除结点的右孩子为<code>null</code>，左孩子不为<code>null</code>，删除结点，左孩子补位，返回左孩子为根结点</li><li>删除结点的左右孩子结点都不为空，则将删除结点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ol><blockquote><p>注意：因为该题所提供的二叉树为搜索二叉树，即删除结点的左子树值皆小于右子树的值，即可将待删结点的左子树置于待删结点的右子树的左叶子结点下。</p></blockquote><p><img src="/img/timu/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif" alt="450.删除二叉搜索树中的节点" title="450.删除二叉搜索树中的节点" /></p><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//当遍历到的结点值为待删结点时</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;<span class="comment">//待删结点的左结点为空，则返回右结点</span></span><br><span class="line">        <span class="keyword">return</span> root.right;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;<span class="comment">//待删结点的右结点为空，则返回左结点</span></span><br><span class="line">        <span class="keyword">return</span> root.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//存储待删结点的右子树头结点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;<span class="comment">//找到待删结点的左叶子结点，作为待删结点左子树的挂载点</span></span><br><span class="line">          cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.left = root.left;<span class="comment">//挂载待删结点的左子树到待删结点的右子树的左叶子结点下</span></span><br><span class="line">        root = root.right;<span class="comment">//删除待删结点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);<span class="comment">//当key小于当前结点值时向左树寻找</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);<span class="comment">//当key大于当前结点时向右树寻找</span></span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//仍然为传入的root</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;/a&gt; 题目&lt;/h1&gt;
&lt;p&gt;给定一个二叉搜索树的根节点&lt;code&gt;root&lt;/code&gt;和一个值&lt;code&gt;key&lt;/code&gt;，删除二叉搜索树中的&lt;code&gt;key&lt;/c</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="搜索二叉树" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树中的插入操作</title>
    <link href="http://example.com/2024/11/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2024/11/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</id>
    <published>2024-11-26T12:29:25.000Z</published>
    <updated>2024-11-27T00:51:04.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>给定二叉搜索树<a href="https://blog.csdn.net/weixin_41811314/article/details/107104079">BST</a>的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。<br />输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>示例1</p><blockquote><ul><li>输入：root = [40,20,60,10,30,50,70], val = 25</li><li>输出：[40,20,60,10,30,50,70,null,null,25]</li></ul></blockquote><p>示例2</p><blockquote><ul><li>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</li><li>输出：[4,2,7,1,3,5]</li></ul></blockquote><p><img src="/img/timu/insertbst.jpg" alt="二叉搜索树中的插入操作" title="力扣701-二叉搜索树中的插入操作" /></p><h2 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h2><ul><li>给定的树上的节点数介于 0 和 10^4 之间</li><li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li><li>-10^8 &lt;= val &lt;= 10^8</li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><blockquote><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">力扣题目链接</a></p></blockquote><blockquote><p><a href="https://www.bilibili.com/video/BV1Et4y1c78Y/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f">《代码随想录》算法公开课</a></p></blockquote><hr /><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><blockquote><p>首先添加结点的位置为叶子结点（不考虑替换中间结点再构建树）。<br />再来考虑截至条件-当遍历到该结点的子节点都为null时即找到了挂载点。<br />根据搜索二叉树的特点，即当<code>val</code>大于<code>root</code>结点值时，向右树寻找，当<code>val</code>小于<code>root</code>结点的值时，向左树寻找。<br />又因为该题提供的二叉树为搜索二叉树，当找到挂载点是，只需判断该值是否大于<code>pre</code>（为循环条件中存储的挂载点）。</p></blockquote><h2 id="迭代法"><a class="markdownIt-Anchor" href="#迭代法"></a> 迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);<span class="comment">//当roo为空时，用val值构建结点返回作为头结点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> root;<span class="comment">//提前存储头结点，作为返回</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root;<span class="comment">//存储用于挂载的结点</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = root;</span><br><span class="line">            <span class="keyword">if</span> (root.val &gt; val) &#123;<span class="comment">//向左树寻找</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;<span class="comment">//向右树寻找</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//与pre做大小比较，最后将val构造的结点挂在树下</span></span><br><span class="line">        <span class="keyword">if</span> (pre.val &gt; val) &#123;</span><br><span class="line">            pre.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="comment">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val); <span class="comment">// 递归创建右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val); <span class="comment">// 递归创建左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;/a&gt; 题目&lt;/h1&gt;
&lt;p&gt;给定二叉搜索树&lt;a href=&quot;https://blog.csdn.net/weixin_41811314/article/details/10</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="搜索二叉树" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第一个Java程序</title>
    <link href="http://example.com/2024/11/26/%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2024/11/26/%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-11-26T07:42:52.000Z</published>
    <updated>2024-11-26T12:36:09.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java简介"><a class="markdownIt-Anchor" href="#java简介"></a> Java简介</h1><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><p><code>Java</code>是一门<code>面向对象</code>的编程语言，不仅吸收了<code>C++</code>语言的各种优点，还摒弃了C++里难以理解的<code>多继承</code>、<code>指针</code>等概念。</p><p>因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ul><li>简单性、分布式、健壮性、安全性、平台独立</li><li>可移植性、多线程、动态性</li></ul><h2 id="java的用途"><a class="markdownIt-Anchor" href="#java的用途"></a> Java的用途</h2><ul><li>桌面应用程序</li><li>Web应用程序</li><li>分布式系统</li><li>嵌入式系统应用程序</li></ul><h2 id="java的发展历程"><a class="markdownIt-Anchor" href="#java的发展历程"></a> Java的发展历程</h2><blockquote><p>Java最初由<code>Sum</code>公司于1991年开发，最初命名为<code>Oak</code><br />后由于名字已被他人使用，将其改为<code>Java</code>并于1995年正式发布<br />后Sum公司于2010年被Oracle公司收购，之后Java便由<code>Oracle</code>公司负责维护和版本升级</p></blockquote><hr /><h1 id="正题步入-第一个java程序"><a class="markdownIt-Anchor" href="#正题步入-第一个java程序"></a> 正题步入-第一个Java程序</h1><ul><li>代码展示:</li></ul><figure class="highlight java"><figcaption><span>main方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java简介&quot;&gt;&lt;/a&gt; Java简介&lt;/h1&gt;
&lt;h2 id=&quot;描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#描述&quot;&gt;&lt;/a&gt; 描述&lt;/h2</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="新手教程" scheme="http://example.com/tags/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
