[{"title":"删除二叉搜索树中的节点","url":"/2024/11/27/删除二叉搜索树中的节点/","content":"# 题目\n给定一个二叉搜索树的根节点`root`和一个值`key`，删除二叉搜索树中的`key`对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n[《代码随想录》算法视频公开课](https://www.bilibili.com/video/BV1tP41177us/?share_source=copy_web&vd_source=fd148478f48deef97bac8ef404e7216f)\n\n[力扣题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/description/)\n\n示例1\n> - 输入：root = [5,3,6,2,4,null,7], key = 3\n> - 输出：[5,4,6,2,null,null,7]\n> - 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它\n图示\n![删除二叉搜索树中的节点](/img/timu/www.jpg \"力扣450-删除二叉搜索树中的节点\")\n示例2\n> - 输入: root = [5,3,6,2,4,null,7], key = 0\n> - 输出: [5,3,6,2,4,null,7]\n> - 解释: 二叉树不包含值为 0 的节点\n示例3\n> - 输入: root = [], key = 0\n> - 输出: []\n\n\n\n\n# 思路\n## 删除结点可能出现的五种情况\n1. 没有找到`key`对应结点：\n    - 没找到删除的节点，遍历到空节点直接返回了\n2. 找到`key`对应的结点：\n    - `key`对应结点的左孩子为`null`，右孩子不为`null`，则直接返回右孩子\n    - `key`对应结点的右孩子为`null`，左孩子不为`null`，则直接返回左孩子\n    - 删除结点的右孩子为`null`，左孩子不为`null`，删除结点，左孩子补位，返回左孩子为根结点\n    - 删除结点的左右孩子结点都不为空，则将删除结点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。\n\n> 注意：因为该题所提供的二叉树为搜索二叉树，即删除结点的左子树值皆小于右子树的值，即可将待删结点的左子树置于待删结点的右子树的左叶子结点下。\n\n![450.删除二叉搜索树中的节点](/img/timu/450.删除二叉搜索树中的节点.gif \"450.删除二叉搜索树中的节点\")\n\n# 代码实现\n```Java\nclass Solution {\n  public TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null) return root;\n    //当遍历到的结点值为待删结点时\n    if (root.val == key) {\n      if (root.left == null) {//待删结点的左结点为空，则返回右结点\n        return root.right;\n      } else if (root.right == null) {//待删结点的右结点为空，则返回左结点\n        return root.left;\n      } else {\n        //存储待删结点的右子树头结点\n        TreeNode cur = root.right;\n        while (cur.left != null) {//找到待删结点的左叶子结点，作为待删结点左子树的挂载点\n          cur = cur.left;\n        }\n        cur.left = root.left;//挂载待删结点的左子树到待删结点的右子树的左叶子结点下\n        root = root.right;//删除待删结点\n        return root;\n      }\n    }\n    if (root.val > key) root.left = deleteNode(root.left, key);//当key小于当前结点值时向左树寻找\n    if (root.val < key) root.right = deleteNode(root.right, key);//当key大于当前结点时向右树寻找\n    return root;//仍然为传入的root\n  }\n}\n```\n\n\n\n","tags":["Java","二叉树","搜索二叉树"],"categories":["二叉树"]},{"title":"二叉搜索树中的插入操作","url":"/2024/11/26/二叉搜索树中的插入操作/","content":"# 题目\n给定二叉搜索树[BST](https://blog.csdn.net/weixin_41811314/article/details/107104079)的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 \n输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。\n\n示例1\n> - 输入：root = [40,20,60,10,30,50,70], val = 25\n> - 输出：[40,20,60,10,30,50,70,null,null,25]\n\n示例2\n> - 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n> - 输出：[4,2,7,1,3,5]\n\n![二叉搜索树中的插入操作](/img/timu/insertbst.jpg \"力扣701-二叉搜索树中的插入操作\")\n\n## 提示\n- 给定的树上的节点数介于 0 和 10^4 之间\n- 每个节点都有一个唯一整数值，取值范围从 0 到 10^8\n- -10^8 <= val <= 10^8\n- 新值和原始二叉搜索树中的任意节点值都不同\n\n> [力扣题目链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1Et4y1c78Y/?share_source=copy_web&vd_source=fd148478f48deef97bac8ef404e7216f)\n\n---\n\n# 思路\n> 首先添加结点的位置为叶子结点（不考虑替换中间结点再构建树）。\n> 再来考虑截至条件-当遍历到该结点的子节点都为null时即找到了挂载点。\n> 根据搜索二叉树的特点，即当`val`大于`root`结点值时，向右树寻找，当`val`小于`root`结点的值时，向左树寻找。\n> 又因为该题提供的二叉树为搜索二叉树，当找到挂载点是，只需判断该值是否大于`pre`（为循环条件中存储的挂载点）。\n\n## 迭代法\n```Java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) return new TreeNode(val);//当roo为空时，用val值构建结点返回作为头结点\n        TreeNode newRoot = root;//提前存储头结点，作为返回\n        TreeNode pre = root;//存储用于挂载的结点\n        while (root != null) {\n            pre = root;\n            if (root.val > val) {//向左树寻找\n                root = root.left;\n            } else if (root.val < val) {//向右树寻找\n                root = root.right;\n            } \n        }\n        //与pre做大小比较，最后将val构造的结点挂在树下\n        if (pre.val > val) {\n            pre.left = new TreeNode(val);\n        } else {\n            pre.right = new TreeNode(val);\n        }\n\n        return newRoot;\n    }\n}\n```\n\n## 递归法\n```Java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) // 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。\n            return new TreeNode(val);\n            \n        if (root.val < val){\n            root.right = insertIntoBST(root.right, val); // 递归创建右子树\n        }else if (root.val > val){\n            root.left = insertIntoBST(root.left, val); // 递归创建左子树\n        }\n        return root;\n    }\n}\n```\n\n","tags":["Java","二叉树","搜索二叉树"],"categories":["二叉树"]},{"title":"第一个Java程序","url":"/2024/11/26/第一个Java程序/","content":"# Java简介\n\n## 描述\n`Java`是一门`面向对象`的编程语言，不仅吸收了`C++`语言的各种优点，还摒弃了C++里难以理解的`多继承`、`指针`等概念。  \n\n因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。\n\n## 特性\n- 简单性、分布式、健壮性、安全性、平台独立\n- 可移植性、多线程、动态性\n\n## Java的用途\n- 桌面应用程序\n- Web应用程序\n- 分布式系统\n- 嵌入式系统应用程序\n\n## Java的发展历程\n> Java最初由`Sum`公司于1991年开发，最初命名为`Oak`\n> 后由于名字已被他人使用，将其改为`Java`并于1995年正式发布\n> 后Sum公司于2010年被Oracle公司收购，之后Java便由`Oracle`公司负责维护和版本升级\n\n---\n\n# 正题步入-第一个Java程序\n- 代码展示:\n``` Java main方法\npublic class Hello{\n    public static void main(String[] args){\n        System.out.println(\"Hello world!\");\n    }\n}\n```\n\n\n\n\n\n\n","tags":["Java","新手教程"],"categories":["Java"]}]