[{"title":"LeetCode-爬楼梯","url":"/2024/11/30/LeetCode-%E7%88%AC%E6%A5%BC%E6%A2%AF/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>假设你正在爬楼梯。需要<code>n</code>阶你才能到达楼顶。每次你可以爬<code>1</code>或<code>2</code>个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<blockquote>\n<p>注意：给定n是一个正整数</p>\n</blockquote>\n<p>示例1</p>\n<ul>\n<li>输入： 2</li>\n<li>输出： 2</li>\n<li>解释： 有两种方法可以爬到楼顶。\n<ul>\n<li>1 阶 + 1 阶</li>\n<li>2 阶</li>\n</ul>\n</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入： 3</li>\n<li>输出： 3</li>\n<li>解释： 有三种方法可以爬到楼顶。\n<ul>\n<li>1 阶 + 1 阶 + 1 阶</li>\n<li>1 阶 + 2 阶</li>\n<li>2 阶 + 1 阶</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV17h411h7UH/\">《代码随想录》算法公开课</a><br />\n<a href=\"https://leetcode.cn/problems/climbing-stairs/description/\">力扣题目链接</a></p>\n</blockquote>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<p>首先，我们举几个栗子：<br />\n爬到第一层阶梯只有 一种方法<br />\n爬到第二层阶梯有两种方法<br />\n爬到第三层阶梯可以由第一层阶梯跨两步，或者由第二层阶梯跨一步<br />\n爬到第四层阶梯可以由第二层阶梯跨两步，或者由第三层阶梯跨一步</p>\n<p>由此我们得到规律：<code>dp[i]=dp[i-1]+dp[i-2]</code>，其中<code>i</code>为阶梯数，<code>dp[i]</code>为爬<code>i</code>层阶梯上顶层得方法数</p>\n<h1 id=\"动态规划五部曲\"><a class=\"markdownIt-Anchor\" href=\"#动态规划五部曲\"></a> 动态规划五部曲</h1>\n<ol>\n<li>确定dp数组以及下标的含义<br />\ndp[i]： 爬到第i层楼梯，有dp[i]种方法</li>\n<li>确定递推公式<br />\n<strong>dp[i] = dp[i - 1] + dp[i - 2]</strong></li>\n<li>dp数组初始化<br />\n需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况，即只有dp[1]=1,dp[2]=2。</li>\n<li>确定遍历顺序<br />\n从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</li>\n<li>举例推导dp数组</li>\n</ol>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"接下来难度升级挑战另一个爬楼梯小问题吧\"><a class=\"markdownIt-Anchor\" href=\"#接下来难度升级挑战另一个爬楼梯小问题吧\"></a> <strong>接下来，难度升级，挑战另一个爬楼梯小问题吧！</strong></h2>\n<h1 id=\"题目-2\"><a class=\"markdownIt-Anchor\" href=\"#题目-2\"></a> 题目</h1>\n<p>给你一个整数数组<code>cost</code>，其中<code>cost[i]</code>是从楼梯第<code>i</code>个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为<code>0</code>或下标为<code>1</code>的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。</p>\n<p>示例1</p>\n<ul>\n<li>输入：cost = [10, <strong>15</strong> ,20]</li>\n<li>输出：15</li>\n<li>解释：你将从下标为 1 的台阶开始。\n<ul>\n<li>支付 15 ，向上爬两个台阶，到达楼梯顶部。<br />\n总花费为 15 。</li>\n</ul>\n</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入：cost = [<strong>1</strong> ,100,<strong>1</strong> ,1,<strong>1</strong> ,100,<strong>1</strong> ,<strong>1</strong> ,100,<strong>1</strong>]</li>\n<li>输出：6</li>\n<li>解释：你将从下标为 0 的台阶开始。\n<ul>\n<li>支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</li>\n<li>支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</li>\n<li>支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</li>\n<li>支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</li>\n<li>支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</li>\n<li>支付 1 ，向上爬一个台阶，到达楼梯顶部。<br />\n总花费为 6 。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV16G411c7yZ/?vd_source=fd148478f48deef97bac8ef404e7216f\">“《代码随想录》算法公开课”</a><br />\n<a href=\"https://leetcode.cn/problems/min-cost-climbing-stairs/description/\">“力扣题目链接”</a></p>\n</blockquote>\n<h1 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路</h1>\n<p>首先我们要知道题目中说的从<code>0</code>或者<code>1</code>开始爬楼梯，便是告诉我们到达<code>0</code>或者<code>1</code>台阶是不需要花费体力，从<code>0</code>或者<code>1</code>向上跳就需要花费体力。</p>\n<h2 id=\"动态规划五部曲-2\"><a class=\"markdownIt-Anchor\" href=\"#动态规划五部曲-2\"></a> 动态规划五部曲</h2>\n<ol>\n<li>\n<p>确定dp数组以及下标的含义<br />\n<strong>dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。</strong></p>\n</li>\n<li>\n<p>确定递推公式<br />\n<strong>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]</strong><br />\ndp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。<br />\ndp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。<br />\n即<strong>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</strong></p>\n</li>\n</ol>\n<blockquote>\n<p>注：给定数组从0索引开始，这里的i代表跨越了i个阶梯，即实际走了i+1个阶梯</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>dp数组如何初始化<br />\n由题目可知dp[0] = 0,dp[1] = 0，dp[2]可以由dp[0]和dp[1]推出，以此类推</p>\n</li>\n<li>\n<p>确定遍历顺序<br />\n由递推公式，我们可以很轻易知晓，该题一定是由前向后遍历</p>\n</li>\n<li>\n<p>举例推导dp数组<br />\n拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：<br />\n<img src=\"/img/timu/746-1.png\" alt=\"746\" title=\"LeetCode746\" /></p>\n</li>\n</ol>\n<h1 id=\"代码实现-2\"><a class=\"markdownIt-Anchor\" href=\"#代码实现-2\"></a> 代码实现</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"type\">int</span>[] cost)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> cost.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[len + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算到达每一层台阶的最小费用</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.min(dp[i - <span class=\"number\">1</span>] + cost[i - <span class=\"number\">1</span>], dp[i - <span class=\"number\">2</span>] + cost[i - <span class=\"number\">2</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["dp","Java"]},{"title":"LeetCode-不同路径","url":"/2024/12/02/LeetCode-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","content":"<h1 id=\"题目-不同路径i\"><a class=\"markdownIt-Anchor\" href=\"#题目-不同路径i\"></a> 题目-不同路径I</h1>\n<p>一个机器人位于一个<code>m x n</code>网格的左上角 （起始点在下图中标记为<code>Start</code>）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为<code>Finish</code>）。<br />\n问总共有多少条不同的路径？<br />\n<img src=\"/img/timu/62-1.png\" alt=\"62-1\" title=\"LeetCode-62\" /></p>\n<p>示例1</p>\n<ul>\n<li>输入：m = 3, n = 7</li>\n<li>输出：28</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入：m = 2, n = 3</li>\n<li>输出：3</li>\n<li>解释： 从左上角开始，总共有 3 条路径可以到达右下角。\n<ol>\n<li>向右 -&gt; 向右 -&gt; 向下</li>\n<li>向右 -&gt; 向下 -&gt; 向右</li>\n<li>向下 -&gt; 向右 -&gt; 向右</li>\n</ol>\n</li>\n</ul>\n<p>示例3</p>\n<ul>\n<li>输入：m = 7, n = 3</li>\n<li>输出：28</li>\n</ul>\n<p>示例4</p>\n<ul>\n<li>输入：m = 3, n = 3</li>\n<li>输出：6</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Ld4y1k7c6/?vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法公开课</a><br />\n<a href=\"https://leetcode.cn/problems/unique-paths-ii/description/\">力扣题目链接</a></p>\n</blockquote>\n<h1 id=\"思路-i\"><a class=\"markdownIt-Anchor\" href=\"#思路-i\"></a> 思路-I</h1>\n<p>首先机械人要到达终点必须要向下走<code>n</code>步，向右走<code>m</code>步，我们将机械人的初始位置表示为<code>(0 , 0)</code>，终点表示为<code>(m-1 , n-1)</code>。</p>\n<h2 id=\"动态规划五部曲-i\"><a class=\"markdownIt-Anchor\" href=\"#动态规划五部曲-i\"></a> 动态规划五部曲-I</h2>\n<ol>\n<li>\n<p>确定<code>dp</code>数组以及下标的含义<br />\n<code>dp[i][j]</code> ：表示从<code>(0 ，0)</code>出发，到<code>(i, j)</code> 有<code>dp[i][j]</code>条不同的路径。</p>\n</li>\n<li>\n<p>确定递推公式<br />\n想要求<code>dp[i][j]</code>，只能有两个方向来推导出来，即从<code>[i][j]</code>位置的上方和左方移动而来，代码表示为<code>dp[i - 1][j]</code>和<code>dp[i][j - 1]</code>。</p>\n</li>\n</ol>\n<p>此时在回顾一下<code>dp[i - 1][j]</code>表示啥，是从<code>(0, 0)</code>的位置到<code>(i - 1, j)</code>有几条路径，<code>dp[i][j - 1]</code>同理。</p>\n<p>那么很自然，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为<code>dp[i][j]</code>只有这两个方向过来。</p>\n<ol start=\"3\">\n<li>\n<p>dp数组的初始化<br />\n如何初始化呢，首先<code>dp[i][0]</code>一定都是<code>1</code>，因为从<code>(0, 0)</code>的位置到<code>(i, 0)</code>的路径只有一条，那么<code>dp[0][j]</code>也同理。</p>\n</li>\n<li>\n<p>确定遍历顺序<br />\n这里要看一下递推公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p>\n</li>\n<li>\n<p>举例推导<code>dp</code>数组<br />\n<img src=\"/img/timu/62-2.png\" alt=\"62-2\" title=\"62-2\" /></p>\n</li>\n</ol>\n<h1 id=\"代码实现-i\"><a class=\"markdownIt-Anchor\" href=\"#代码实现-i\"></a> 代码实现-I</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//行列的索引都从0出发，则终点位置索引为[m-1][n-1]</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"comment\">//初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++)dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++)dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//因为每次只能向下或向右移动一步，则dp[i][j] 只能来自dp[i][j-1]向右移动一步，或者dp[i-1][j]向下移动一步</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                dp[i][j] = dp[i-<span class=\"number\">1</span>][j] + dp[i][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"题目-不同路径ii\"><a class=\"markdownIt-Anchor\" href=\"#题目-不同路径ii\"></a> 题目-不同路径II</h1>\n<p>一个机器人位于一个<code>m x n</code>网格的左上角 （起始点在下图中标记为<code>Start</code>）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为<code>Finish</code>）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n<blockquote>\n<p>注：网格中的障碍物和空位置分别用<code>1</code>和<code>0</code>来表示。</p>\n</blockquote>\n<p>示例1</p>\n<ul>\n<li>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</li>\n<li>输出：2</li>\n<li>解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：\n<ol>\n<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>\n<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br />\n<img src=\"/img/timu/63-1.png\" alt=\"63-1\" title=\"63-1\" /></li>\n</ol>\n</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入：obstacleGrid = [[0,1],[0,0]]</li>\n<li>输出：1</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Ld4y1k7c6/?vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法公开课</a><br />\n<a href=\"https://leetcode.cn/problems/unique-paths-ii/description/\">力扣题目链接</a></p>\n</blockquote>\n<h1 id=\"思路-ii\"><a class=\"markdownIt-Anchor\" href=\"#思路-ii\"></a> 思路-II</h1>\n<p>首先这个题跟不同路径I很相似，则我们定义<code>dp[i][j]</code>为到达<code>(i,j)</code>的路径数，已知有障碍就无法通行，且<code>dp</code>数组会遍历到网格上的每一个点，则我们只需要令以障碍点为终点的路径删去就是没有障碍的路径，在这个思路中我们直接排除了含障碍点的路径。</p>\n<h2 id=\"动态规划五部曲-ii\"><a class=\"markdownIt-Anchor\" href=\"#动态规划五部曲-ii\"></a> 动态规划五部曲-II</h2>\n<ol>\n<li>\n<p>确定<code>dp</code>数组以及下标的含义<br />\n<code>dp[i][j]</code>：表示从<code>(0 ，0)</code>出发，到<code>(i, j)</code>有<code>dp[i][j]</code>条不同的路径。</p>\n</li>\n<li>\n<p>确定递推公式<br />\n递推公式和62.不同路径一样，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>。</p>\n</li>\n</ol>\n<blockquote>\n<p>注：但这里需要注意一点，因为有了障碍，<code>(i, j)</code>如果就是障碍的话应该就保持初始状态（初始状态为0）。</p>\n</blockquote>\n<ol start=\"3\">\n<li><code>dp</code>数组如何初始化<br />\n在<code>(i,0)</code>不是障碍物之前，其路径数都是<code>1</code>，当<code>(i,0)</code>位置为障碍物之后，其路径数都为<code>0</code>.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class=\"number\">0</span>] != <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class=\"number\">0</span>][j] != <span class=\"number\">1</span>; j++)&#123;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注：注意代码里for循环的终止条件，一旦遇obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理</strong></p>\n</blockquote>\n<ol start=\"4\">\n<li>\n<p>确定遍历顺序<br />\n从递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1] </code>中可以看出，一定是从左到右一层一层遍历，这样保证推导<code>dp[i][j]</code>的时候<code>dp[i - 1][j]</code>和<code>dp[i][j - 1]</code>一定是有数值。</p>\n</li>\n<li>\n<p>举例推导<code>dp</code>数组<br />\n自己想象</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">uniquePathsWithObstacles</span><span class=\"params\">(<span class=\"type\">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> obstacleGrid.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> obstacleGrid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(obstacleGrid[m-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>] == <span class=\"number\">1</span> || obstacleGrid[<span class=\"number\">0</span>][<span class=\"number\">0</span>] == <span class=\"number\">1</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//遇到障碍物后面都是0,数组的初始值都是0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class=\"number\">0</span>] != <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class=\"number\">0</span>][j] != <span class=\"number\">1</span>; j++)&#123;</span><br><span class=\"line\">           dp[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//dp数组会普及到每一个位置，只要当前是障碍物就直接不通，默认初始值为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                dp[i][j] = (obstacleGrid[i][j] == <span class=\"number\">0</span>)? dp[i-<span class=\"number\">1</span>][j] + dp[i][j-<span class=\"number\">1</span>] : <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["动态规划"],"tags":["dp","Java","LeetCode"]},{"title":"一维与二维前缀和与差分","url":"/2024/11/29/%E4%B8%80%E7%BB%B4%E4%B8%8E%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","content":"<h1 id=\"什么是前缀和\"><a class=\"markdownIt-Anchor\" href=\"#什么是前缀和\"></a> 什么是前缀和？</h1>\n<h2 id=\"一维数组前缀和\"><a class=\"markdownIt-Anchor\" href=\"#一维数组前缀和\"></a> 一维数组前缀和</h2>\n<p>例如数组nums = [1,2,3,4,5]</p>\n<p>则其前缀和数组为<code>qian = [1,3,6,10,15]</code>，即<code>qian</code>数组的<code>i</code>索引位置处的值为<code>nums</code>数组索引<code>0-i</code>值的和</p>\n<p>则有如下关系：<code>nums[i] = qian[i] - qian[i-1]</code></p>\n<blockquote>\n<p>注：使用该方法有一最大优势便是可以以<code>(O1)</code>的时间复杂度得到某块区间的总和，是典型的牺牲空间换取时间</p>\n</blockquote>\n<h2 id=\"二维数组前缀和\"><a class=\"markdownIt-Anchor\" href=\"#二维数组前缀和\"></a> 二维数组前缀和</h2>\n<h3 id=\"二维数组的应用和计算\"><a class=\"markdownIt-Anchor\" href=\"#二维数组的应用和计算\"></a> 二维数组的应用和计算</h3>\n<p>二维数组前缀和是一种在二维矩阵上进行快速区域求和的技术，它是一维前缀和概念的扩展。在二维数组中，前缀和可以帮助我们快速计算任意子矩阵的元素和，这在处理图像处理或者某些区域查询问题时非常有用。</p>\n<h3 id=\"二维前缀和的定义\"><a class=\"markdownIt-Anchor\" href=\"#二维前缀和的定义\"></a> 二维前缀和的定义</h3>\n<p>二维前缀和是指对于一个给定的二维数组<code>a</code>，我们构建一个新的二维数组<code>sum</code>，其中<code>sum[i][j]</code>表示从<code>a[0][0]</code>到<code>a[i][j]</code>所有元素的和。这样<code>sum</code>数组的每个元素都代表了一个矩形区域内元素的总和。</p>\n<h3 id=\"计算二维前缀和\"><a class=\"markdownIt-Anchor\" href=\"#计算二维前缀和\"></a> 计算二维前缀和</h3>\n<p>计算二维前缀和的过程可以通过动态规划的方式来完成。对于数组<code>a</code>中的每个元素<code>a[i][j]</code>，我们可以根据以下公式来计算<code>sum[i][j]</code></p>\n<blockquote>\n<p>sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[i][j]</p>\n</blockquote>\n<h3 id=\"使用二维前缀和求子矩阵和\"><a class=\"markdownIt-Anchor\" href=\"#使用二维前缀和求子矩阵和\"></a> 使用二维前缀和求子矩阵和</h3>\n<p>一旦我们计算出了二维前缀和数组<code>sum</code>，我们就可以快速求出任意子矩阵的和。假设我们要求从<code>(x1, y1)</code>到<code>(x2, y2)</code>形成的子矩阵的和，我们可以使用以下公式</p>\n<blockquote>\n<p>subSum = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1]</p>\n</blockquote>\n<h3 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrefixSum</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[][] getPrefixSum(<span class=\"type\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> matrix.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建一个新的二维数组用于存储前缀和</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] prefixSum = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][n];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算第一行的前缀和</span></span><br><span class=\"line\">        prefixSum[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            prefixSum[<span class=\"number\">0</span>][j] = prefixSum[<span class=\"number\">0</span>][j - <span class=\"number\">1</span>] + matrix[<span class=\"number\">0</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算第一列的前缀和</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            prefixSum[i][<span class=\"number\">0</span>] = prefixSum[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + matrix[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算其余位置的前缀和</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                prefixSum[i][j] = prefixSum[i - <span class=\"number\">1</span>][j] + prefixSum[i][j - <span class=\"number\">1</span>] - prefixSum[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + matrix[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> prefixSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"差分法\"><a class=\"markdownIt-Anchor\" href=\"#差分法\"></a> 差分法</h1>\n<h2 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\"></a> 定义</h2>\n<p>对于已知有<code>n</code>个元素的一维数列<code>nums</code>，我们可以建立记录它与每项与前一项得差值得差分数组<code>f</code>；显然，<code>f[1] = nums[1] - 0 = nums[1]</code>; 对于整数 <code>i∈[2,n]</code>，我们让<code>f[i]=nums[i]-nums[i-1]</code>。将对<code>nums</code>的一些操作转移至<code>f</code>数列，最终合并<code>f</code>得到<code>nums</code>的一种操作，叫做差分法。</p>\n<h2 id=\"举个栗子\"><a class=\"markdownIt-Anchor\" href=\"#举个栗子\"></a> 举个栗子</h2>\n<ul>\n<li>例如 nums=[3,4,1,5,6,2,7,9]</li>\n<li>即，f=[3,1,-3,4,1,-4,5,-2]<br />\n当我们需要对数组的<code>[1,6]</code>，这个区间的数<code>+1</code>，并求处区间<code>+1</code>后数组的值</li>\n<li>此时，我们只需要对<code>f</code>数组的左边界第<code>1</code>项<code>+1</code>，对<code>f</code>数组的右边界第<code>7</code>项<code>-1</code>，此时<code>f=[4,1,-3,4,1,-4,4,2]</code>，因为第一项<code>+1</code>，导致<code>1-6</code>项的差值都<code>+1</code>了，即完成对给定区间进行<code>+1</code>操作</li>\n</ul>\n<h2 id=\"差分法的用途\"><a class=\"markdownIt-Anchor\" href=\"#差分法的用途\"></a> 差分法的用途</h2>\n<blockquote>\n<ul>\n<li>快速处理区间加减操作</li>\n<li>优化时间复杂度，也是典型的牺牲空间换时间</li>\n<li>对数组f求前缀和即可得到原数组nums</li>\n</ul>\n</blockquote>\n<h2 id=\"代码实现-2\"><a class=\"markdownIt-Anchor\" href=\"#代码实现-2\"></a> 代码实现</h2>\n<h3 id=\"对给定数组求差分数组\"><a class=\"markdownIt-Anchor\" href=\"#对给定数组求差分数组\"></a> 对给定数组求差分数组</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] getDifferenceArray(<span class=\"type\">int</span>[] arr) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] diffArray = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\"></span><br><span class=\"line\">        diffArray[<span class=\"number\">0</span>] = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            diffArray[i] = arr[i] - arr[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> diffArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对给定数组求差分数组后通过前缀和得到原数组\"><a class=\"markdownIt-Anchor\" href=\"#对给定数组求差分数组后通过前缀和得到原数组\"></a> 对给定数组求差分数组后通过前缀和得到原数组</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] getArray(<span class=\"type\">int</span>[] diffArray) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> diffArray.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] originalArray = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\"></span><br><span class=\"line\">        originalArray[<span class=\"number\">0</span>] = diffArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            originalArray[i] = originalArray[i - <span class=\"number\">1</span>] + diffArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["前缀和与差分"],"tags":["Java","前缀和","数组","差分"]},{"title":"买卖股票的最佳时机II","url":"/2024/11/29/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定一个数组，它的第<code>i</code>个元素是一支给定股票第<code>i</code>天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<blockquote>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n</blockquote>\n<p>示例1</p>\n<ul>\n<li>输入: [7,1,5,3,6,4]</li>\n<li>输出: 7</li>\n<li>解释: 在第2天（股票价格 = 1）的时候买入，在第3天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第4天（股票价格 = 3）的时候买入，在第5天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入: [1,2,3,4,5]</li>\n<li>输出: 4</li>\n<li>解释: 在第1天（股票价格 = 1）的时候买入，在第5天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第1天和第2天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</li>\n</ul>\n<p>示例3</p>\n<ul>\n<li>输入: [7,6,4,3,1]</li>\n<li>输出: 0</li>\n<li>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1ev4y1C7na/\">《代码随想录》算法公开课</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/\">力扣题目链接</a></p>\n</blockquote>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<ul>\n<li>首先，我们手上只能有一支股票，根据题目可知，要想产生利润，必须得是前一天股票的价值小于第二天的，这样我们的差值才会大于<code>0</code>。</li>\n<li>把数组分成一个个递增的小片段，当有值大于前一个值时便进行利润计算，再把一个个小片段进行累加，得到最终结果。- 只要有利润，我们就要，这便是<code>局部最优</code>，把每个小利润加起来得到的最大值，便是<code>全局最优</code>。</li>\n</ul>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//作为返回值，统计结果</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前股票值高于前一天，即差值大于0，则加入利润中</span></span><br><span class=\"line\">            result += Math.max(prices[i] - prices[i - <span class=\"number\">1</span>], <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["贪心算法"],"tags":["Java","贪心算法"]},{"title":"二叉搜索树中的插入操作","url":"/2024/11/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定二叉搜索树<a href=\"https://blog.csdn.net/weixin_41811314/article/details/107104079\">BST</a>的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。<br />\n输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p>示例1</p>\n<blockquote>\n<ul>\n<li>输入：root = [40,20,60,10,30,50,70], val = 25</li>\n<li>输出：[40,20,60,10,30,50,70,null,null,25]</li>\n</ul>\n</blockquote>\n<p>示例2</p>\n<blockquote>\n<ul>\n<li>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</li>\n<li>输出：[4,2,7,1,3,5]</li>\n</ul>\n</blockquote>\n<p><img src=\"/img/timu/insertbst.jpg\" alt=\"二叉搜索树中的插入操作\" title=\"力扣701-二叉搜索树中的插入操作\" /></p>\n<h2 id=\"提示\"><a class=\"markdownIt-Anchor\" href=\"#提示\"></a> 提示</h2>\n<ul>\n<li>给定的树上的节点数介于 0 和 10^4 之间</li>\n<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>\n<li>-10^8 &lt;= val &lt;= 10^8</li>\n<li>新值和原始二叉搜索树中的任意节点值都不同</li>\n</ul>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/insert-into-a-binary-search-tree/\">力扣题目链接</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Et4y1c78Y/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法公开课</a></p>\n</blockquote>\n<hr />\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<blockquote>\n<p>首先添加结点的位置为叶子结点（不考虑替换中间结点再构建树）。<br />\n再来考虑截至条件-当遍历到该结点的子节点都为null时即找到了挂载点。<br />\n根据搜索二叉树的特点，即当<code>val</code>大于<code>root</code>结点值时，向右树寻找，当<code>val</code>小于<code>root</code>结点的值时，向左树寻找。<br />\n又因为该题提供的二叉树为搜索二叉树，当找到挂载点是，只需判断该值是否大于<code>pre</code>（为循环条件中存储的挂载点）。</p>\n</blockquote>\n<h2 id=\"迭代法\"><a class=\"markdownIt-Anchor\" href=\"#迭代法\"></a> 迭代法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">insertIntoBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);<span class=\"comment\">//当roo为空时，用val值构建结点返回作为头结点</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">newRoot</span> <span class=\"operator\">=</span> root;<span class=\"comment\">//提前存储头结点，作为返回</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> root;<span class=\"comment\">//存储用于挂载的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            pre = root;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.val &gt; val) &#123;<span class=\"comment\">//向左树寻找</span></span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &lt; val) &#123;<span class=\"comment\">//向右树寻找</span></span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//与pre做大小比较，最后将val构造的结点挂在树下</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pre.val &gt; val) &#123;</span><br><span class=\"line\">            pre.left = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pre.right = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> newRoot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"递归法\"><a class=\"markdownIt-Anchor\" href=\"#递归法\"></a> 递归法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">insertIntoBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"comment\">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt; val)&#123;</span><br><span class=\"line\">            root.right = insertIntoBST(root.right, val); <span class=\"comment\">// 递归创建右子树</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &gt; val)&#123;</span><br><span class=\"line\">            root.left = insertIntoBST(root.left, val); <span class=\"comment\">// 递归创建左子树</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["Java","二叉树","搜索二叉树"]},{"title":"修剪二叉搜索树","url":"/2024/11/27/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定一个二叉搜索树，同时给定最小边界<code>low</code>和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中<code>(high&gt;=low)</code> 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>\n<blockquote>\n<p>示例1</p>\n<ul>\n<li>输入：root = [1,0,2], low = 1, high = 2</li>\n<li>输出：[1,null,2]<br />\n<img src=\"/img/timu/669-1.jpg\" alt=\"修剪二叉树\" title=\"修剪二叉搜索树\" /></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>示例2</p>\n<ul>\n<li>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</li>\n<li>输出：[3,2,null,1]<br />\n<img src=\"/img/timu/669-2.jpg\" alt=\"修剪二叉树\" title=\"修剪二叉搜索树\" /></li>\n</ul>\n</blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV17P41177ud/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法视频公开课</a></p>\n<p><a href=\"https://leetcode.cn/problems/trim-a-binary-search-tree/description/\">力扣题目链接</a></p>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<ul>\n<li>题目所给二叉树为搜索二叉树</li>\n<li>首先判断根结点是否在给定范围内，如果大于给定范围，则返回其根结点的左结点作为输出树的根结点，如果小于给定范围，则返回根结点的右结点作为根结点</li>\n<li>记录当前根结点，先向左树进行遍历剪切</li>\n<li>再次记录根结点，向右树进行遍历剪切</li>\n</ul>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h1>\n<h2 id=\"迭代法\"><a class=\"markdownIt-Anchor\" href=\"#迭代法\"></a> 迭代法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">trimBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"comment\">//首先对根结点进行判断--是否超越给定边界</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root != <span class=\"literal\">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//小于则返回根结点的右结点作为边界</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root.val &lt; low) root = root.right;</span><br><span class=\"line\">            <span class=\"comment\">//反则返回根结点的左结点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> root = root.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//记录当前根结点，用于下述的遍历</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">cur</span>  <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"comment\">//遍历左树，寻找是否有需要剪切的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur.left != <span class=\"literal\">null</span> &amp;&amp; cur.left.val &lt; low)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//进行剪切操作，因为当cur.left.val小于边界时，其左子树全部小于，直接全切了，右树同样操作</span></span><br><span class=\"line\">                cur.left = cur.left.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur.right != <span class=\"literal\">null</span> &amp;&amp; cur.right.val &gt; high)&#123;</span><br><span class=\"line\">                cur.right = cur.right.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["二叉树"],"tags":["Java","二叉树","搜索二叉树"]},{"title":"删除二叉搜索树中的节点","url":"/2024/11/27/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定一个二叉搜索树的根节点<code>root</code>和一个值<code>key</code>，删除二叉搜索树中的<code>key</code>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1tP41177us/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法视频公开课</a></p>\n<p><a href=\"https://leetcode.cn/problems/delete-node-in-a-bst/description/\">力扣题目链接</a></p>\n<blockquote>\n<p>示例1</p>\n<ul>\n<li>输入：root = [5,3,6,2,4,null,7], key = 3</li>\n<li>输出：[5,4,6,2,null,null,7]</li>\n<li>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它<br />\n图示<br />\n<img src=\"/img/timu/www.jpg\" alt=\"删除二叉搜索树中的节点\" title=\"力扣450-删除二叉搜索树中的节点\" /><br />\n示例2</li>\n<li>输入: root = [5,3,6,2,4,null,7], key = 0</li>\n<li>输出: [5,3,6,2,4,null,7]</li>\n<li>解释: 二叉树不包含值为 0 的节点<br />\n示例3</li>\n<li>输入: root = [], key = 0</li>\n<li>输出: []</li>\n</ul>\n</blockquote>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<h2 id=\"删除结点可能出现的五种情况\"><a class=\"markdownIt-Anchor\" href=\"#删除结点可能出现的五种情况\"></a> 删除结点可能出现的五种情况</h2>\n<ol>\n<li>没有找到<code>key</code>对应结点：\n<ul>\n<li>没找到删除的节点，遍历到空节点直接返回了</li>\n</ul>\n</li>\n<li>找到<code>key</code>对应的结点：\n<ul>\n<li><code>key</code>对应结点的左孩子为<code>null</code>，右孩子不为<code>null</code>，则直接返回右孩子</li>\n<li><code>key</code>对应结点的右孩子为<code>null</code>，左孩子不为<code>null</code>，则直接返回左孩子</li>\n<li>删除结点的右孩子为<code>null</code>，左孩子不为<code>null</code>，删除结点，左孩子补位，返回左孩子为根结点</li>\n<li>删除结点的左右孩子结点都不为空，则将删除结点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注意：因为该题所提供的二叉树为搜索二叉树，即删除结点的左子树值皆小于右子树的值，即可将待删结点的左子树置于待删结点的右子树的左叶子结点下。</p>\n</blockquote>\n<p><img src=\"/img/timu/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif\" alt=\"450.删除二叉搜索树中的节点\" title=\"450.删除二叉搜索树中的节点\" /></p>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">deleteNode</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"comment\">//当遍历到的结点值为待删结点时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.val == key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//待删结点的左结点为空，则返回右结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.right;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.right == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//待删结点的右结点为空，则返回左结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.left;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//存储待删结点的右子树头结点</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> root.right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.left != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//找到待删结点的左叶子结点，作为待删结点左子树的挂载点</span></span><br><span class=\"line\">          cur = cur.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.left = root.left;<span class=\"comment\">//挂载待删结点的左子树到待删结点的右子树的左叶子结点下</span></span><br><span class=\"line\">        root = root.right;<span class=\"comment\">//删除待删结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);<span class=\"comment\">//当key小于当前结点值时向左树寻找</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);<span class=\"comment\">//当key大于当前结点时向右树寻找</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;<span class=\"comment\">//仍然为传入的root</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["Java","二叉树","搜索二叉树"]},{"title":"动态规划入门","url":"/2024/11/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/","content":"<h1 id=\"动态规划简介\"><a class=\"markdownIt-Anchor\" href=\"#动态规划简介\"></a> 动态规划简介</h1>\n<p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p>\n<p>所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。</p>\n<h2 id=\"动态规划五部曲\"><a class=\"markdownIt-Anchor\" href=\"#动态规划五部曲\"></a> 动态规划五部曲</h2>\n<blockquote>\n<ol>\n<li>确定dp数组（dp table）以及下标的含义</li>\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导dp数组</li>\n</ol>\n</blockquote>\n<p><strong>注：一些情况是递推公式决定了dp数组要如何初始化！</strong></p>\n<h2 id=\"动态规划应该如何debug\"><a class=\"markdownIt-Anchor\" href=\"#动态规划应该如何debug\"></a> 动态规划应该如何debug</h2>\n<p>当我们去学动态规划的题很容易出现看完题解，自己上手写代码一直通过不了，首先我们要明白，<strong>写动态规划，代码出问题很正常！</strong></p>\n<p>debug：</p>\n<blockquote>\n<p>把dp数组打印出来，看看究竟是不是自己的思路所推演的结果</p>\n</blockquote>\n<p>写动态规划最忌讳的就是不清楚dp数组的含义，不懂为什么这样初始化，只会一味的去背代码，要明白，不是所有的题都能凭借所谓的题感直接写出来的，我们得去明白其深层得含义，理解自己为什么要这样去操作。</p>\n<p><strong>我们在去写代码之前，一定要先把状态转移到dp数组上进行具体得模拟一遍，做到心里有数</strong></p>\n<p>通过不了时，请给自己发出以下三个疑问：</p>\n<blockquote>\n<p>这道题目我举例推导状态转移公式了么？<br />\n我打印dp数组的日志了么？<br />\n打印出来了dp数组和我想的一样么？</p>\n</blockquote>\n<p>通过上述文字，想必我们对动态规划已经有了初步得了解，那我们就来试试下面这道题目把！</p>\n<h1 id=\"小题一道\"><a class=\"markdownIt-Anchor\" href=\"#小题一道\"></a> 小题一道</h1>\n<h2 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h2>\n<p>斐波那契数，通常用<code>F(n)</code>表示，形成的序列称为 斐波那契数列 。该数列由<code>0</code>和<code>1</code>开始，后面的每一项数字都是前面两项数字的和。也就是： <code>F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)</code>，其中<code>n &gt; 1</code>给你<code>n</code>，请计算<code>F(n)</code>。<br />\n示例1</p>\n<ul>\n<li>输入：2</li>\n<li>输出：1</li>\n<li>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入：3</li>\n<li>输出：2</li>\n<li>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</li>\n</ul>\n<p>示例3</p>\n<ul>\n<li>输入：4</li>\n<li>输出：3</li>\n<li>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1f5411K7mo/?vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法公开课</a><br />\n<a href=\"https://leetcode.cn/problems/fibonacci-number/description/\">力扣题目链接</a></p>\n</blockquote>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ol>\n<li>确定dp数组以及下标的含义<br />\ndp[i]的定义为：第i个数的斐波那契数值是dp[i]</li>\n<li>确定递推公式<br />\n状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</li>\n<li>dp数组如何初始化<br />\n题目已经告诉我们：dp[0]=0, dp[1]=1</li>\n<li>确定遍历顺序<br />\n从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</li>\n<li>举例推导dp数组<br />\n按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为8的时候，dp数组应该是如下的数列：<code>0 1 1 2 3 5 8 13 21</code></li>\n</ol>\n<blockquote>\n<p>注：如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>\n</blockquote>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h2>\n<h3 id=\"完整dp解题代码\"><a class=\"markdownIt-Anchor\" href=\"#完整dp解题代码\"></a> 完整dp解题代码</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">fib</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> n;             </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; index &lt;= n; index++)&#123;</span><br><span class=\"line\">            dp[index] = dp[index - <span class=\"number\">1</span>] + dp[index - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简化后的dp解题代码\"><a class=\"markdownIt-Anchor\" href=\"#简化后的dp解题代码\"></a> 简化后的dp解题代码</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">fib</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, b = <span class=\"number\">1</span>, c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            c = a + b;</span><br><span class=\"line\">            a = b;</span><br><span class=\"line\">            b = c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归解题代码\"><a class=\"markdownIt-Anchor\" href=\"#递归解题代码\"></a> 递归解题代码</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">fib</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">2</span>)<span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n-<span class=\"number\">1</span>) + fib(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["Java","斐波那契数","新手教程"]},{"title":"最大子序和","url":"/2024/11/29/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定一个整数数组<code>nums</code>，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p>示例1</p>\n<ul>\n<li>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</li>\n<li>输出：6</li>\n<li>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入：nums = [1]</li>\n<li>输出：1</li>\n</ul>\n<p>示例3<br />\n输入：nums = [5,4,-1,7,8]<br />\n输出：23</p>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1aY4y1Z7ya/\">《代码随想录》算法公开课</a><br />\n<a href=\"https://leetcode.cn/problems/maximum-subarray/description/\">力扣题目链接</a></p>\n</blockquote>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<h2 id=\"暴力解法\"><a class=\"markdownIt-Anchor\" href=\"#暴力解法\"></a> 暴力解法</h2>\n<ul>\n<li>暴力解法的思路，第一层<code>for</code>就是设置起始位置，第二层 <code>for</code>循环遍历数组寻找最大值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将结果设为最小整数，以便于后续结果做对比不被影响</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"comment\">//单个子序列的总和</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//每次进行新一轮遍历时，都重置子序列和</span></span><br><span class=\"line\">            count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &lt; nums,length; j++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//固定外层nums[i]移动j指针，寻找最大子序列和</span></span><br><span class=\"line\">                count += nums[j];</span><br><span class=\"line\">                <span class=\"comment\">//当前子序列和大于res时，将其count值赋给res</span></span><br><span class=\"line\">                res = count &gt; res ? count : res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：此方法的时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>，一般会超过题目给定的时间限制，提示超时错误</p>\n</blockquote>\n<h2 id=\"贪心算法\"><a class=\"markdownIt-Anchor\" href=\"#贪心算法\"></a> 贪心算法</h2>\n<p>所谓贪心算法，就是在子序和为负数时，直接舍弃当前<code>count</code>，对其<code>count</code>进行重新赋值<code>0</code>的操作，因为负数只会拉低综合，这便是局部最优。</p>\n<p><strong>从代码角度上来讲：遍历<code>nums</code>，从头开始用<code>count</code>累积，如果<code>count</code>一旦加上<code>nums[i]</code>变为负数，那么就应该从<code>nums[i+1]</code>开始从<code>0</code>累积<code>count</code>了，因为已经变为负数的<code>count</code>，只会拖累总和。</strong></p>\n<ul>\n<li><strong>注：这相当于是暴力解法中的不断调整最大子序和区间的起始位置。</strong></li>\n</ul>\n<h3 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当长度为1时直接返回其值便是最大子序和</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将返回值初始为整型最小值，以便后续赋值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            count += nums[i];</span><br><span class=\"line\">            <span class=\"comment\">//先对比取出最大值，再判断count是否&lt;0，这么做是为了防止最大值便是负数导致遗漏</span></span><br><span class=\"line\">            max = Math.max(max, count); </span><br><span class=\"line\">            <span class=\"comment\">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                count = <span class=\"number\">0</span>; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["贪心算法"],"tags":["Java","贪心算法"]},{"title":"摆动序列","url":"/2024/11/28/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>\n<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>\n<p>例如，<code>[1,7,4,9,2,5]</code>是一个摆动序列，因为差值 <code>(6,-3,5,-7,3) </code>是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和<code>[1,7,4,5,5]</code>不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>\n<p>示例1</p>\n<ul>\n<li>输入: [1,7,4,9,2,5]</li>\n<li>输出: 6</li>\n<li>解释: 整个序列均为摆动序列。</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入: [1,17,5,10,13,15,10,5,16,8]</li>\n<li>输出: 7</li>\n<li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li>\n</ul>\n<p>示例3</p>\n<ul>\n<li>输入: [1,2,3,4,5,6,7,8,9]</li>\n<li>输出: 2</li>\n</ul>\n<p><a href=\"https://www.bilibili.com/video/BV17M411b7NS/\">《代码随想录》算法公开课</a><br />\n<a href=\"https://leetcode.cn/problems/wiggle-subsequence/description/\">力扣题目链接</a></p>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<h2 id=\"题意分析\"><a class=\"markdownIt-Anchor\" href=\"#题意分析\"></a> 题意分析</h2>\n<blockquote>\n<p>首先，题目需要的是摆动序列，即先将数列进行列出，如下图<br />\n<img src=\"/img/timu/376-1.jpg\" alt=\"376摆动序列\" title=\"摆动序列\" /><br />\n<img src=\"/img/timu/376-2.jpg\" alt=\"376-1摆动序列\" title=\"摆动序列\" /><br />\n摆动序列即数列列出的形状如同波浪线一般，在该题中我们可以删去某些元素再进行排序，由贪心算法的每次取局部最优，得到全局最优，我们每次都只取峰值元素，即当有片段单调递增或单调递减时，我们支取最高点或者最低点。<br />\n如示例2：<br />\n<img src=\"/img/timu/376-3.png\" alt=\"376-2摆动序列\" title=\"摆动序列\" /></p>\n<ul>\n<li><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。</strong></li>\n<li><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</strong></li>\n</ul>\n</blockquote>\n<h2 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\"></a> 注意</h2>\n<ol>\n<li>上下坡中有平坡<br />\n例如：[1,2,2,2,1]<br />\n<img src=\"/img/timu/376-4.png\" alt=\"摆动序列\" title=\"摆动序列\" /></li>\n</ol>\n<ul>\n<li>当我们遇到平波时，相同的元素支取一次就行了，此时同一一下规则，删除左边的相同元素，即<code>(prediff &gt;= 0 &amp;&amp; curdiff &lt; 0 ) || (prediff &lt;= 0 &amp;&amp; curdiff &gt; 0)</code>。</li>\n</ul>\n<blockquote>\n<p>注：<code>curdiff</code>为当前元素与前一元素的差值，<code>prediff</code>为前一元素与其前一元素的差值。</p>\n</blockquote>\n<ol start=\"2\">\n<li>数组首尾两端</li>\n</ol>\n<ul>\n<li>对于这种特殊情况我们可以定死规则，即当数组大小为2时，<code>nums[0] != nums[1]</code>即返回2</li>\n</ul>\n<ol start=\"3\">\n<li>单调坡中有平坡<br />\n例如：[1,2,2,2,3,4]<br />\n<img src=\"/img/timu/376-5.png\" alt=\"摆动序列\" title=\"摆动序列\" /></li>\n</ol>\n<ul>\n<li>对于这种情况我们只需要规定<code>prediff</code>的更新时间即可，即当有坡度变化时才去更新<code>prediff</code>的值。</li>\n</ul>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">wiggleMaxLength</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//长度为2，且元素不相等时，为摆动序列，直接返回2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">2</span> &amp;&amp; (nums[<span class=\"number\">0</span>] != nums[<span class=\"number\">1</span>]))<span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//当前差值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">curDiff</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//上一个差值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">preDiff</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//记录返回值，即摆动序列长度，从索引1处开始，则至少有一个数满足题意</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//得到当前差值</span></span><br><span class=\"line\">            curDiff = nums[i] - nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"comment\">//如果当前差值和上一个差值为一正一负</span></span><br><span class=\"line\">            <span class=\"comment\">//等于0的情况表示初始时的preDiff</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((curDiff &gt; <span class=\"number\">0</span> &amp;&amp; preDiff &lt;= <span class=\"number\">0</span>) || (curDiff &lt; <span class=\"number\">0</span> &amp;&amp; preDiff &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                preDiff = curDiff;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["贪心算法"],"tags":["Java","贪心算法"]},{"title":"贪心算法-分发饼干","url":"/2024/11/28/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/","content":"<h1 id=\"什么是贪心算法\"><a class=\"markdownIt-Anchor\" href=\"#什么是贪心算法\"></a> 什么是贪心算法</h1>\n<ul>\n<li>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</li>\n<li>例如有一堆不同数额的钞票，每次只能拿一张，怎么拿能取得最大数额的钞票。\n<ul>\n<li>方法：将钞票从大到小进行排序，每次都拿走当前堆里最大面额的钞票，即可在指定拿取次数中获得最大数额的钞票。</li>\n<li>例如：[100, 100, 50, 20, 50, 1, 10]\n<ul>\n<li>排序后为：[100, 100, 50, 50, 20, 10, 1]</li>\n<li>依次取数组中的最大值进行累加</li>\n<li>取完指定次数后，累加值即为最优解</li>\n</ul>\n</li>\n<li>在这个过程中，每次取最大面额的钞票为<code>局部最优</code>，通过每次获得<code>局部最优</code>得到的结果即为<code>全局最优</code>。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：贪心算法并没有固定套路，也没有固定策略，贪心算法有时候就是常识的推导，所以认为本应该这么做！</p>\n</blockquote>\n<h1 id=\"小题一道-分发饼干\"><a class=\"markdownIt-Anchor\" href=\"#小题一道-分发饼干\"></a> 小题一道-分发饼干</h1>\n<h2 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h2>\n<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>\n<p>对每个孩子<code>i</code>，都有一个胃口值<code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干<code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干<code>j</code> 分配给孩子<code>i</code>，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>\n<blockquote>\n<p>示例1</p>\n<ul>\n<li>输入: g = [1,2,3], s = [1,1]</li>\n<li>输出: 1</li>\n<li>解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>示例2</p>\n<ul>\n<li>输入: g = [1,2], s = [1,2,3]</li>\n<li>输出: 2</li>\n<li>解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.</li>\n</ul>\n</blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1MM411b7cq/\">《代码随想录》算法公开课</a></p>\n<p><a href=\"https://leetcode.cn/problems/assign-cookies/description/\">力扣题目链接</a></p>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>首先，每个孩子只能获得一块饼干，大尺寸的饼干能满足对于饼干需求小于等于该尺寸的孩子</li>\n<li>为了减少饼干的浪费，这里我们优先考虑将大尺寸的饼干给到胃口大的孩子</li>\n<li>即此处的<code>局部最优</code>便是，将大尺寸的饼干分给胃口大的孩子，<code>全局最优</code>便是尽量喂饱更多孩子<br />\n<img src=\"/img/timu/455-1.png\" alt=\"分发饼干-代码随想录\" title=\"分发饼干\" /></li>\n</ul>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h1>\n<h2 id=\"优先考虑胃口先喂饱大胃口的孩子\"><a class=\"markdownIt-Anchor\" href=\"#优先考虑胃口先喂饱大胃口的孩子\"></a> 优先考虑胃口，先喂饱大胃口的孩子</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//优先考虑胃口，先喂饱大胃口</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findContentChildren</span><span class=\"params\">(<span class=\"type\">int</span>[] g, <span class=\"type\">int</span>[] s)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(g);<span class=\"comment\">//对两个数组进行升序排序</span></span><br><span class=\"line\">        Arrays.sort(s);</span><br><span class=\"line\">        <span class=\"comment\">//count统计被喂饱的孩子</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//饼干尺寸从大到小进行与孩子胃口匹配</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> s.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历胃口</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> g.length - <span class=\"number\">1</span>; index &gt;= <span class=\"number\">0</span>; index--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//start &gt;= 0为了防止数组越界错误</span></span><br><span class=\"line\">            <span class=\"comment\">//当饼干尺寸满足孩子时，将饼干分给g[index],然后饼干向更小的尺寸移动，孩子也向胃口更小的移动，如果孩子胃口大于饼干尺寸，则无法满足该孩子，直接向胃口小的孩子移动</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(start &gt;= <span class=\"number\">0</span> &amp;&amp; g[index] &lt;= s[start]) &#123;</span><br><span class=\"line\">                start--;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"优先考虑饼干小饼干先喂饱小胃口\"><a class=\"markdownIt-Anchor\" href=\"#优先考虑饼干小饼干先喂饱小胃口\"></a> 优先考虑饼干，小饼干先喂饱小胃口</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findContentChildren</span><span class=\"params\">(<span class=\"type\">int</span>[] g, <span class=\"type\">int</span>[] s)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(g);</span><br><span class=\"line\">        Arrays.sort(s);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length &amp;&amp; start &lt; g.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] &gt;= g[start]) &#123;</span><br><span class=\"line\">                start++;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["贪心算法"],"tags":["Java","贪心算法"]},{"title":"第一个Java程序","url":"/2024/11/26/%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F/","content":"<h1 id=\"java简介\"><a class=\"markdownIt-Anchor\" href=\"#java简介\"></a> Java简介</h1>\n<h2 id=\"描述\"><a class=\"markdownIt-Anchor\" href=\"#描述\"></a> 描述</h2>\n<p><code>Java</code>是一门<code>面向对象</code>的编程语言，不仅吸收了<code>C++</code>语言的各种优点，还摒弃了C++里难以理解的<code>多继承</code>、<code>指针</code>等概念。</p>\n<p>因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p>\n<h2 id=\"特性\"><a class=\"markdownIt-Anchor\" href=\"#特性\"></a> 特性</h2>\n<ul>\n<li>简单性、分布式、健壮性、安全性、平台独立</li>\n<li>可移植性、多线程、动态性</li>\n</ul>\n<h2 id=\"java的用途\"><a class=\"markdownIt-Anchor\" href=\"#java的用途\"></a> Java的用途</h2>\n<ul>\n<li>桌面应用程序</li>\n<li>Web应用程序</li>\n<li>分布式系统</li>\n<li>嵌入式系统应用程序</li>\n</ul>\n<h2 id=\"java的发展历程\"><a class=\"markdownIt-Anchor\" href=\"#java的发展历程\"></a> Java的发展历程</h2>\n<blockquote>\n<p>Java最初由<code>Sum</code>公司于1991年开发，最初命名为<code>Oak</code><br />\n后由于名字已被他人使用，将其改为<code>Java</code>并于1995年正式发布<br />\n后Sum公司于2010年被Oracle公司收购，之后Java便由<code>Oracle</code>公司负责维护和版本升级</p>\n</blockquote>\n<hr />\n<h1 id=\"正题步入-第一个java程序\"><a class=\"markdownIt-Anchor\" href=\"#正题步入-第一个java程序\"></a> 正题步入-第一个Java程序</h1>\n<ul>\n<li>代码展示:</li>\n</ul>\n<figure class=\"highlight java\"><figcaption><span>main方法</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Hello</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Java"],"tags":["Java","新手教程"]},{"title":"跳跃游戏","url":"/2024/11/29/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p>\n<p>示例1</p>\n<ul>\n<li>输入: [2,3,1,1,4]</li>\n<li>输出: true</li>\n<li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li>\n</ul>\n<p>示例2</p>\n<ul>\n<li>输入: [3,2,1,0,4]</li>\n<li>输出: false</li>\n<li>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</li>\n</ul>\n<p>示例3</p>\n<ul>\n<li>输入: [0]</li>\n<li>输出: true</li>\n<li>解释: 跳入的第一步就到终点了</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1VG4y1X7kB/?vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法公开课</a><br />\n<a href=\"https://leetcode.cn/problems/jump-game/description/\">力扣题目链接</a></p>\n</blockquote>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<ul>\n<li>每次跳跃都使其覆盖的范围为给定步数里覆盖的最大范围</li>\n<li>直到其到达终点，或所覆盖范围超过终点</li>\n<li>此时的局部最优便是：每次所跳步数可以使下一次跳覆盖最大范围</li>\n<li>全局最优便是：每次跳最优达到步数最大</li>\n<li>最后判断全局最优的结果能不能覆盖终点</li>\n</ul>\n<p><img src=\"/img/timu/55-1.png\" alt=\"55-1跳跃游戏\" title=\"跳跃游戏\" /></p>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canJump</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//覆盖范围, 初始覆盖范围应该是0，因为下面的迭代是从下标0开始的</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">coverRange</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//在覆盖范围内更新最大的覆盖范围</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= coverRange; i++) &#123;</span><br><span class=\"line\">            coverRange = Math.max(coverRange, i + nums[i]);</span><br><span class=\"line\">            <span class=\"comment\">//覆盖范围超过数组长度，即可达到终点，结束判断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (coverRange &gt;= nums.length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["Java","贪心算法"]}]