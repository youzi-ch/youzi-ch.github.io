[{"title":"动态规划-01背包理论基础(二)","url":"/2024/12/06/动态规划/动态规划-01背包理论基础2/","content":"# 动态规划-01背包理论基础(二)\n上一篇我们提到了01背包的二维的dp数组，这篇我们就来说一说01背包的一维数组，也就是滚动数组，为什么叫滚动数组看完接下来的分析你就懂了！\n\n那么我们通过01背包，来彻底讲一讲滚动数组！\n接下来还是用如下这个例子来进行讲解：\n> weight = [1, 3, 4]\n> value = [15, 20, 30]\n\n## 一维dp数组（滚动数组）\n对于背包问题其实状态都是可以压缩的!\n\n在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`;\n\n其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，即利用上一层的数据将二维表达式里的dp[i-1][j]直接用上一次遍历的结果，即数组进行了一个滚动操作，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])`;\n\n与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）\n\n> 注：我们千万不能忘记dp[i][j]的含义！dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。\n\n## 动态规划五部曲\n1. 确定dp数组的定义\n\ndp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。\n\n2. 一维dp数组的递推公式\n\n二维dp数组的递推公式为： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n\n以下为分析：\n\n- dp[j]为 容量为j的背包所背的最大价值。\n\n- dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。\n\n- dp[j - weight[i]] + value[i] 表示 容量为 [j - 物品i重量] 的背包加上物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）\n\n- 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值。\n\n3. 一维dp数组如何初始化\n\ndp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。\n\n那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？\n\n看一下递归公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`;\n\ndp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。\n\n这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。\n\n那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。\n\n4. 一维dp数组遍历顺序\n\n代码如下：\n```Java\nfor(int i = 0; i < weight.size(); i++) { // 遍历物品\n    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量\n        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\n    }\n}\n```\n> 这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。\n\n为什么呢？**倒序遍历是为了保证物品i只被放入一次！**但如果一旦正序遍历了，那么物品0就会被重复加入多次！\n\n- 举个例子：物品0的重量weight[0] = 1，价值value[0] = 15\n\n如果正序遍历\n\ndp[1] = dp[1 - weight[0]] + value[0] = 15\ndp[2] = dp[2 - weight[0]] + value[0] = 30\n此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。\n\n为什么倒序遍历，就可以保证物品只放入一次呢？\n\n倒序就是先算dp[2]\ndp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）\ndp[1] = dp[1 - weight[0]] + value[0] = 15\n\n所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。\n\n**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**\n\n**不可以！**\n\n因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。\n\n**所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！**这一点大家一定要注意。\n\n5. 举例推导dp数组\n\n一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：\n![01背包](/img/timu/01-2-1.png \"01背包\")\n像不像二维数组的每条都滚动展示！\n\n> [01背包原题](https://kamacoder.com/problempage.php?pid=1046)\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1BU4y177kY/?vd_source=fd148478f48deef97bac8ef404e7216f)\n\n## 代码实现\n```Java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取 M 和 N\n        int M = scanner.nextInt();  // 研究材料的数量\n        int N = scanner.nextInt();  // 行李空间的大小\n\n        int[] costs = new int[M];   // 每种材料的空间占用\n        int[] values = new int[M];  // 每种材料的价值\n\n        // 输入每种材料的空间占用\n        for (int i = 0; i < M; i++) {\n            costs[i] = scanner.nextInt();\n        }\n\n        // 输入每种材料的价值\n        for (int j = 0; j < M; j++) {\n            values[j] = scanner.nextInt();\n        }\n\n        // 创建一个动态规划数组 dp，初始值为 0\n        int[] dp = new int[N + 1];\n\n        // 外层循环遍历每个类型的研究材料\n        for (int i = 0; i < M; i++) {\n            // 内层循环从 N 空间逐渐减少到当前研究材料所占空间\n            for (int j = N; j >= costs[i]; j--) {\n                // 考虑当前研究材料选择和不选择的情况，选择最大值\n                dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);\n            }\n        }\n\n        // 输出 dp[N]，即在给定 N 行李空间可以携带的研究材料的最大价值\n        System.out.println(dp[N]);\n\n        scanner.close();\n    }\n}\n```\n","tags":["Java","dp","一维数组"],"categories":["01背包"]},{"title":"动态规划-01背包理论基础(一)","url":"/2024/12/05/动态规划/动态规划-01背包理论基础/","content":"# 动态规划：01背包理论基础(一)\n\n## 背包分类图\n![01背包](/img/timu/01-1.png \"01背包\")\n\n## 什么是01背包？\n### 01背包\n有`n`件物品和一个最多能背重量为`w`的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i]` 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。\n### 关于其他背包\n- 除01背包以外其他类型的背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。\n- 而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。\n- **所以背包问题的理论基础重中之重是01背包，一定要理解透！**\n\n## 举个栗子\nweight = [1, 3, 4]\nvalue = [15, 20, 30]\n> 注：下面所出现的数字都以此例子为例\n\n### 二维dp数组01背包\n动态规划五部曲：\n1. 确定dp数组以及下标的含义\n\n我们有两个维度需要分别表示：物品和背包容量，即有0-i个放入j容量的背包所拿到的最大价值，其中0-i个物品皆可选择是否放入，且物品唯一，如下图：\n![01背包](/img/timu/01-2.png \"01背包\")\n（如果想用j 表示物品，j表示背包容量 行不行？ 都可以的，个人习惯而已）\n然后我们来逐一分析一下：\n\n**首先是把物品0放入背包的情况，weight[0] = 1, value[0] = 15:**\n![01背包](/img/timu/01-3.png \"01背包\")\n背包容量为0，放不下物品0，此时背包里的价值为0。\n\n背包容量为1，可以放下物品0，此时背包里的价值为15.\n\n背包容量为2，依然可以放下物品0 （注意 01背包里物品只有一个），此时背包里的价值为15。\n以此类推。\n\n**然后是0物品和1物品同时有的情况：**\n![01背包](/img/timu/01-4.png \"01背包\")\n背包容量为 0，放不下物品0 或者物品1，此时背包里的价值为0。\n背包容量为 1，只能放下物品0，背包里的价值为15。\n\n背包容量为 2，只能放下物品0，背包里的价值为15。\n\n背包容量为 3，上一行同一状态，背包只能放物品0，这次也可以选择物品1了，背包可以放物品1 或者 物品0，物品1价值更大，背包里的价值为20。\n\n背包容量为 4，上一行同一状态，背包只能放物品0，这次也可以选择物品1了，背包可以放下物品0 和 物品1，背包价值为35。\n\n通过这个举例，我们来进一步明确dp数组的含义。\n即`dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。`\n\n2. 确定递推公式\n\n对于递推公式，首先我们要明确有哪些方向可以推导出`dp[i][j]`。\n这里我们以`dp[1][4]`为例：\n首先我们有物品0和物品1，`dp[1][4]`有两种情况：放物品1？还是不放物品1？\n\n如果`不放`物品1，则背包价值应该为`dp[0][4]`，如果`放`物品1，则我们应该预先留出放物品1的空间，则此时的`j`为`4-weight[1]`，且我们是没有放物品1的，则此时的`i`\n为`i-1`，则我们推出了两种`dp[1][4]`的来源，此时我们只需要取其最大价值即可。即递推方程为：\n`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`\n\n3. dp数组初始化\n首先从`dp[i][j]`的定义出发，如果背包容量j为0的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0。如图：\n![01背包](/img/timu/01-5.png \"01背包\")\n\n状态转移方程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`; 可以看出`i`是由 `i-1`推导出来，那么i为0的时候就一定要初始化。\n\n`dp[0][j]`，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。\n\n那么很明显当`j < weight[0]`的时候`dp[0][j]`应该是 0，因为背包容量比编号0的物品重量还小。\n\n当`j >= weight[0]`时`dp[0][j]`应该是`value[0]`，因为背包容量放足够放编号0物品。\n\n代码如下：\n```Java\n//在创建数组时就已经初始为0了 ，可以省略\nfor(int j = 0; j < weight[0]; j++){\n    dp[0][j] = 0;\n}\n\nfor(int j = weight[0]; j <= bagWeight; j++){\n    dp[0][j] = value[0];\n}\n```\n\n结果如下图：\n![01背包](/img/timu/01-06.png \"01背包\")\n\n4. 确定遍历顺序\n\n由递推公式可知dp[i][j]由它二维数组的左上方推演而来，则其先遍历背包容量或者先遍历物品都是可以的，看自己习惯。\n\n5. 举例推导dp数组\n\n自己在纸上推演，再来写代码,结果如图：\n![01背包](/img/timu/01-7.jpg \"01背包\")\n\n> [01背包原题](https://kamacoder.com/problempage.php?pid=1046)\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1cg411g7Y6/?vd_source=fd148478f48deef97bac8ef404e7216f)\n\n### 代码实现\n```Java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int bagWeight = scanner.nextInt();\n\n        //定义两个数组用于接收给定数据\n        int[] weight = new int[n];\n        int[] value = new int[n];\n\n        //接收键盘端传入的两个数组\n        for (int i = 0; i < n; ++i) {\n            weight[i] = scanner.nextInt();\n        }\n        for (int j = 0; j < n; ++j) {\n            value[j] = scanner.nextInt();\n        }\n\n        //根据上述分析去定义dp数组\n        int[][] dp = new int[n][bagWeight + 1];\n\n        //对dp数组进行初始化\n        for (int j = weight[0]; j <= bagWeight; j++) {\n            dp[0][j] = value[0];\n        }\n\n        //递推遍历数组\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j <= bagWeight; j++) {\n                //如果当前的物品重量大于背包容量，则dp取值为不放入i物品的最大价值，即dp[i][j] = dp[i - 1][j]\n                if (j < weight[i]) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n                }\n            }\n        }\n\n        //输出结果[n-1]为从数组中任取的0-i元素，[bagWeight]为背包的最大容量，结果为最大价值\n        System.out.println(dp[n - 1][bagWeight]);\n    }\n}\n\n```","tags":["Java","dp","二维数组"],"categories":["01背包"]},{"title":"LeetCode-不同路径","url":"/2024/12/02/动态规划/LeetCode-不同路径/","content":"# 题目-不同路径I\n一个机器人位于一个`m x n`网格的左上角 （起始点在下图中标记为`Start`）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为`Finish`）。\n问总共有多少条不同的路径？\n![62-1](/img/timu/62-1.png \"LeetCode-62\")\n\n示例1\n- 输入：m = 3, n = 7\n- 输出：28\n\n示例2\n- 输入：m = 2, n = 3\n- 输出：3\n- 解释： 从左上角开始，总共有 3 条路径可以到达右下角。\n  1. 向右 -> 向右 -> 向下\n  2. 向右 -> 向下 -> 向右\n  3. 向下 -> 向右 -> 向右\n\n示例3\n- 输入：m = 7, n = 3\n- 输出：28\n\n示例4\n- 输入：m = 3, n = 3\n- 输出：6\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1Ld4y1k7c6/?vd_source=fd148478f48deef97bac8ef404e7216f)\n> [力扣题目链接](https://leetcode.cn/problems/unique-paths-ii/description/)\n\n# 思路-I\n首先机械人要到达终点必须要向下走`n`步，向右走`m`步，我们将机械人的初始位置表示为`(0 , 0)`，终点表示为`(m-1 , n-1)`。\n\n## 动态规划五部曲-I\n1. 确定`dp`数组以及下标的含义\n`dp[i][j]` ：表示从`(0 ，0)`出发，到`(i, j)` 有`dp[i][j]`条不同的路径。\n\n2. 确定递推公式\n想要求`dp[i][j]`，只能有两个方向来推导出来，即从`[i][j]`位置的上方和左方移动而来，代码表示为`dp[i - 1][j]`和`dp[i][j - 1]`。\n\n此时在回顾一下`dp[i - 1][j]`表示啥，是从`(0, 0)`的位置到`(i - 1, j)`有几条路径，`dp[i][j - 1]`同理。\n\n那么很自然，`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，因为`dp[i][j]`只有这两个方向过来。\n\n3. dp数组的初始化\n如何初始化呢，首先`dp[i][0]`一定都是`1`，因为从`(0, 0)`的位置到`(i, 0)`的路径只有一条，那么`dp[0][j]`也同理。\n\n4. 确定遍历顺序\n这里要看一下递推公式`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，`dp[i][j]`都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。\n\n5. 举例推导`dp`数组\n![62-2](/img/timu/62-2.png \"62-2\")\n\n# 代码实现-I\n```Java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //行列的索引都从0出发，则终点位置索引为[m-1][n-1]\n        int[][] dp = new int[m][n];\n        //初始化\n        for(int i = 0; i < m; i++)dp[i][0] = 1;\n        for(int i = 0; i < n; i++)dp[0][i] = 1;\n\n        //因为每次只能向下或向右移动一步，则dp[i][j] 只能来自dp[i][j-1]向右移动一步，或者dp[i-1][j]向下移动一步\n        for(int i = 1; i < m; i++){\n            for(int j = 1; j < n; j++){\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n\n        return dp[m-1][n-1];\n    }\n}\n```\n\n# 题目-不同路径II\n一个机器人位于一个`m x n`网格的左上角 （起始点在下图中标记为`Start`）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为`Finish`）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n> 注：网格中的障碍物和空位置分别用`1`和`0`来表示。\n\n示例1\n- 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n- 输出：2 \n- 解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：\n  1. 向右 -> 向右 -> 向下 -> 向下\n  2. 向下 -> 向下 -> 向右 -> 向右\n![63-1](/img/timu/63-1.png \"63-1\")\n\n示例2\n- 输入：obstacleGrid = [[0,1],[0,0]]\n- 输出：1\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1Ld4y1k7c6/?vd_source=fd148478f48deef97bac8ef404e7216f)\n> [力扣题目链接](https://leetcode.cn/problems/unique-paths-ii/description/)\n\n# 思路-II\n首先这个题跟不同路径I很相似，则我们定义`dp[i][j]`为到达`(i,j)`的路径数，已知有障碍就无法通行，且`dp`数组会遍历到网格上的每一个点，则我们只需要令以障碍点为终点的路径删去就是没有障碍的路径，在这个思路中我们直接排除了含障碍点的路径。\n\n## 动态规划五部曲-II\n1. 确定`dp`数组以及下标的含义\n`dp[i][j]`：表示从`(0 ，0)`出发，到`(i, j)`有`dp[i][j]`条不同的路径。\n\n2. 确定递推公式\n递推公式和62.不同路径一样，`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`。\n> 注：但这里需要注意一点，因为有了障碍，`(i, j)`如果就是障碍的话应该就保持初始状态（初始状态为0）。\n\n3. `dp`数组如何初始化\n在`(i,0)`不是障碍物之前，其路径数都是`1`，当`(i,0)`位置为障碍物之后，其路径数都为`0`.\n```Java\nfor(int i = 0; i < m && obstacleGrid[i][0] != 1; i++){\n    dp[i][0] = 1;\n}   \nfor(int j = 0; j < n && obstacleGrid[0][j] != 1; j++){\n    dp[0][j] = 1;\n}\n```\n> **注：注意代码里for循环的终止条件，一旦遇obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理**\n\n4. 确定遍历顺序\n从递归公式`dp[i][j] = dp[i - 1][j] + dp[i][j - 1] `中可以看出，一定是从左到右一层一层遍历，这样保证推导`dp[i][j]`的时候`dp[i - 1][j]`和`dp[i][j - 1]`一定是有数值。\n\n5. 举例推导`dp`数组\n自己想象\n\n```Java\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length;\n        int n = obstacleGrid[0].length;\n\n        int[][] dp = new int[m][n];\n        if(obstacleGrid[m-1][n-1] == 1 || obstacleGrid[0][0] == 1)return 0;\n        //遇到障碍物后面都是0,数组的初始值都是0\n        for(int i = 0; i < m && obstacleGrid[i][0] != 1; i++){\n            dp[i][0] = 1;\n        }   \n        for(int j = 0; j < n && obstacleGrid[0][j] != 1; j++){\n           dp[0][j] = 1;\n        }\n\n        //dp数组会普及到每一个位置，只要当前是障碍物就直接不通，默认初始值为0\n        for(int i = 1; i < m; i++){\n            for(int j = 1; j < n; j++){\n                dp[i][j] = (obstacleGrid[i][j] == 0)? dp[i-1][j] + dp[i][j-1] : 0;\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}\n```","tags":["Java","dp","LeetCode"],"categories":["动态规划"]},{"title":"LeetCode-爬楼梯","url":"/2024/11/30/动态规划/LeetCode-爬楼梯/","content":"# 题目\n假设你正在爬楼梯。需要`n`阶你才能到达楼顶。每次你可以爬`1`或`2`个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n> 注意：给定n是一个正整数\n\n示例1\n- 输入： 2\n- 输出： 2\n- 解释： 有两种方法可以爬到楼顶。\n  - 1 阶 + 1 阶\n  - 2 阶\n\n示例2\n- 输入： 3\n- 输出： 3\n- 解释： 有三种方法可以爬到楼顶。\n  - 1 阶 + 1 阶 + 1 阶\n  - 1 阶 + 2 阶\n  - 2 阶 + 1 阶\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV17h411h7UH/)\n> [力扣题目链接](https://leetcode.cn/problems/climbing-stairs/description/)\n\n# 思路\n首先，我们举几个栗子：\n爬到第一层阶梯只有 一种方法\n爬到第二层阶梯有两种方法\n爬到第三层阶梯可以由第一层阶梯跨两步，或者由第二层阶梯跨一步\n爬到第四层阶梯可以由第二层阶梯跨两步，或者由第三层阶梯跨一步\n\n由此我们得到规律：`dp[i]=dp[i-1]+dp[i-2]`，其中`i`为阶梯数，`dp[i]`为爬`i`层阶梯上顶层得方法数\n# 动态规划五部曲\n1. 确定dp数组以及下标的含义 \ndp[i]： 爬到第i层楼梯，有dp[i]种方法\n2. 确定递推公式\n**dp[i] = dp[i - 1] + dp[i - 2]**\n3. dp数组初始化\n需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况，即只有dp[1]=1,dp[2]=2。\n4. 确定遍历顺序\n从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的\n5. 举例推导dp数组\n# 代码实现\n```Java\npublic int climbStairs(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n```\n**接下来，难度升级，挑战另一个爬楼梯小问题吧！**\n---\n# 题目\n给你一个整数数组`cost`，其中`cost[i]`是从楼梯第`i`个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为`0`或下标为`1`的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。\n\n示例1\n- 输入：cost = [10, **15** ,20]\n- 输出：15\n- 解释：你将从下标为 1 的台阶开始。\n  - 支付 15 ，向上爬两个台阶，到达楼梯顶部。\n总花费为 15 。\n\n示例2\n- 输入：cost = [**1** ,100,**1** ,1,**1** ,100,**1** ,**1** ,100,**1**]\n- 输出：6\n- 解释：你将从下标为 0 的台阶开始。\n  - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\n  - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\n  - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\n  - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\n  - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\n  - 支付 1 ，向上爬一个台阶，到达楼梯顶部。\n总花费为 6 。\n\n> [\"《代码随想录》算法公开课\"](https://www.bilibili.com/video/BV16G411c7yZ/?vd_source=fd148478f48deef97bac8ef404e7216f)\n> [\"力扣题目链接\"](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)\n\n# 思路\n首先我们要知道题目中说的从`0`或者`1`开始爬楼梯，便是告诉我们到达`0`或者`1`台阶是不需要花费体力，从`0`或者`1`向上跳就需要花费体力。\n\n## 动态规划五部曲\n1. 确定dp数组以及下标的含义\n**dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。**\n\n2. 确定递推公式\n**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**\ndp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。\ndp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。\n即**dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);**\n\n> 注：给定数组从0索引开始，这里的i代表跨越了i个阶梯，即实际走了i+1个阶梯\n\n3. dp数组如何初始化\n由题目可知dp[0] = 0,dp[1] = 0，dp[2]可以由dp[0]和dp[1]推出，以此类推\n \n4. 确定遍历顺序\n由递推公式，我们可以很轻易知晓，该题一定是由前向后遍历\n\n5. 举例推导dp数组\n拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：\n![746](/img/timu/746-1.png \"LeetCode746\")\n\n# 代码实现\n```Java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int len = cost.length;\n        int[] dp = new int[len + 1];\n\n        // 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0\n        dp[0] = 0;\n        dp[1] = 0;\n\n        // 计算到达每一层台阶的最小费用\n        for (int i = 2; i <= len; i++) {\n            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n\n        return dp[len];\n    }\n}\n```\n","tags":["Java","dp"],"categories":["动态规划"]},{"title":"动态规划入门","url":"/2024/11/30/动态规划/动态规划入门/","content":"# 动态规划简介\n动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。\n\n所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。\n\n## 动态规划五部曲\n> 1. 确定dp数组（dp table）以及下标的含义\n> 2. 确定递推公式\n> 3. dp数组如何初始化\n> 4. 确定遍历顺序\n> 5. 举例推导dp数组\n\n**注：一些情况是递推公式决定了dp数组要如何初始化！**\n\n## 动态规划应该如何debug\n当我们去学动态规划的题很容易出现看完题解，自己上手写代码一直通过不了，首先我们要明白，**写动态规划，代码出问题很正常！**\n\ndebug：\n> 把dp数组打印出来，看看究竟是不是自己的思路所推演的结果\n\n写动态规划最忌讳的就是不清楚dp数组的含义，不懂为什么这样初始化，只会一味的去背代码，要明白，不是所有的题都能凭借所谓的题感直接写出来的，我们得去明白其深层得含义，理解自己为什么要这样去操作。\n\n**我们在去写代码之前，一定要先把状态转移到dp数组上进行具体得模拟一遍，做到心里有数**\n\n通过不了时，请给自己发出以下三个疑问：\n> 这道题目我举例推导状态转移公式了么？\n> 我打印dp数组的日志了么？\n> 打印出来了dp数组和我想的一样么？\n\n通过上述文字，想必我们对动态规划已经有了初步得了解，那我们就来试试下面这道题目把！\n\n# 小题一道\n## 题目\n斐波那契数，通常用`F(n)`表示，形成的序列称为 斐波那契数列 。该数列由`0`和`1`开始，后面的每一项数字都是前面两项数字的和。也就是： `F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)`，其中`n > 1`给你`n`，请计算`F(n)`。\n示例1\n- 输入：2\n- 输出：1\n- 解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n\n示例2\n- 输入：3\n- 输出：2\n- 解释：F(3) = F(2) + F(1) = 1 + 1 = 2\n\n示例3\n- 输入：4\n- 输出：3\n- 解释：F(4) = F(3) + F(2) = 2 + 1 = 3\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1f5411K7mo/?vd_source=fd148478f48deef97bac8ef404e7216f)\n> [力扣题目链接](https://leetcode.cn/problems/fibonacci-number/description/)\n\n## 思路\n1. 确定dp数组以及下标的含义\ndp[i]的定义为：第i个数的斐波那契数值是dp[i]\n2. 确定递推公式\n状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];\n3. dp数组如何初始化\n题目已经告诉我们：dp[0]=0, dp[1]=1\n4. 确定遍历顺序\n从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的\n5. 举例推导dp数组\n按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为8的时候，dp数组应该是如下的数列：`0 1 1 2 3 5 8 13 21`\n\n> 注：如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。\n\n## 代码实现\n### 完整dp解题代码\n```Java\nclass Solution {\n    public int fib(int n) {\n        if (n <= 1) return n;             \n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int index = 2; index <= n; index++){\n            dp[index] = dp[index - 1] + dp[index - 2];\n        }\n        return dp[n];\n    }\n}\n```\n\n### 简化后的dp解题代码\n```Java\nclass Solution {\n    public int fib(int n) {\n        if (n < 2) return n;\n        int a = 0, b = 1, c = 0;\n        for (int i = 1; i < n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return c;\n    }\n}\n```\n### 递归解题代码\n\n```Java\npublic class Solution{\n    public int fib(int n){\n        if(n < 2)return n;\n        return fib(n-1) + fib(n-2);\n    }\n}\n```\n","tags":["Java","斐波那契数","新手教程"],"categories":["动态规划"]},{"title":"一维与二维前缀和与差分","url":"/2024/11/29/其他/一维与二维前缀和与差分/","content":"# 什么是前缀和？\n## 一维数组前缀和\n例如数组nums = [1,2,3,4,5]\n\n则其前缀和数组为`qian = [1,3,6,10,15]`，即`qian`数组的`i`索引位置处的值为`nums`数组索引`0-i`值的和\n\n则有如下关系：`nums[i] = qian[i] - qian[i-1]`\n\n> 注：使用该方法有一最大优势便是可以以`(O1)`的时间复杂度得到某块区间的总和，是典型的牺牲空间换取时间\n\n## 二维数组前缀和\n### 二维数组的应用和计算\n二维数组前缀和是一种在二维矩阵上进行快速区域求和的技术，它是一维前缀和概念的扩展。在二维数组中，前缀和可以帮助我们快速计算任意子矩阵的元素和，这在处理图像处理或者某些区域查询问题时非常有用。\n\n### 二维前缀和的定义\n二维前缀和是指对于一个给定的二维数组`a`，我们构建一个新的二维数组`sum`，其中`sum[i][j]`表示从`a[0][0]`到`a[i][j]`所有元素的和。这样`sum`数组的每个元素都代表了一个矩形区域内元素的总和。\n\n### 计算二维前缀和\n计算二维前缀和的过程可以通过动态规划的方式来完成。对于数组`a`中的每个元素`a[i][j]`，我们可以根据以下公式来计算`sum[i][j]`\n> sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[i][j]\n\n### 使用二维前缀和求子矩阵和\n一旦我们计算出了二维前缀和数组`sum`，我们就可以快速求出任意子矩阵的和。假设我们要求从`(x1, y1)`到`(x2, y2)`形成的子矩阵的和，我们可以使用以下公式\n> subSum = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1]\n\n### 代码实现\n```Java\npublic class PrefixSum {\n    public static int[][] getPrefixSum(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        // 创建一个新的二维数组用于存储前缀和\n        int[][] prefixSum = new int[m][n];\n\n        // 计算第一行的前缀和\n        prefixSum[0][0] = matrix[0][0];\n        for (int j = 1; j < n; j++) {\n            prefixSum[0][j] = prefixSum[0][j - 1] + matrix[0][j];\n        }\n\n        // 计算第一列的前缀和\n        for (int i = 1; i < m; i++) {\n            prefixSum[i][0] = prefixSum[i - 1][0] + matrix[i][0];\n        }\n\n        // 计算其余位置的前缀和\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1] + matrix[i][j];\n            }\n        }\n\n        return prefixSum;\n    }\n}\n```\n\n# 差分法\n## 定义\n对于已知有`n`个元素的一维数列`nums`，我们可以建立记录它与每项与前一项得差值得差分数组`f`；显然，`f[1] = nums[1] - 0 = nums[1]`; 对于整数 `i∈[2,n]`，我们让`f[i]=nums[i]-nums[i-1]`。将对`nums`的一些操作转移至`f`数列，最终合并`f`得到`nums`的一种操作，叫做差分法。\n\n## 举个栗子\n- 例如 nums=[3,4,1,5,6,2,7,9]\n- 即，f=[3,1,-3,4,1,-4,5,-2]\n当我们需要对数组的`[1,6]`，这个区间的数`+1`，并求处区间`+1`后数组的值\n- 此时，我们只需要对`f`数组的左边界第`1`项`+1`，对`f`数组的右边界第`7`项`-1`，此时`f=[4,1,-3,4,1,-4,4,2]`，因为第一项`+1`，导致`1-6`项的差值都`+1`了，即完成对给定区间进行`+1`操作\n\n## 差分法的用途\n> - 快速处理区间加减操作\n> - 优化时间复杂度，也是典型的牺牲空间换时间\n> - 对数组f求前缀和即可得到原数组nums\n\n## 代码实现\n### 对给定数组求差分数组\n```Java\npublic class Main{\n    public static int[] getDifferenceArray(int[] arr) {\n        int n = arr.length;\n        int[] diffArray = new int[n];\n\n        diffArray[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            diffArray[i] = arr[i] - arr[i - 1];\n        }\n\n        return diffArray;\n    }\n}\n```\n\n### 对给定数组求差分数组后通过前缀和得到原数组\n```Java\npublic class Main{\n    public static int[] getArray(int[] diffArray) {\n        int n = diffArray.length;\n        int[] originalArray = new int[n];\n\n        originalArray[0] = diffArray[0];\n        for (int i = 1; i < n; i++) {\n            originalArray[i] = originalArray[i - 1] + diffArray[i];\n        }\n\n        return originalArray;\n    }\n}\n```\n","tags":["Java","前缀和","数组","差分"],"categories":["前缀和与差分"]},{"title":"跳跃游戏","url":"/2024/11/29/贪心算法/跳跃游戏/","content":"# 题目\n给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。\n\n示例1\n- 输入: [2,3,1,1,4]\n- 输出: true\n- 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n\n示例2\n- 输入: [3,2,1,0,4]\n- 输出: false\n- 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n\n示例3\n- 输入: [0]\n- 输出: true\n- 解释: 跳入的第一步就到终点了\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1VG4y1X7kB/?vd_source=fd148478f48deef97bac8ef404e7216f)\n> [力扣题目链接](https://leetcode.cn/problems/jump-game/description/)\n\n# 思路\n- 每次跳跃都使其覆盖的范围为给定步数里覆盖的最大范围\n- 直到其到达终点，或所覆盖范围超过终点\n- 此时的局部最优便是：每次所跳步数可以使下一次跳覆盖最大范围\n- 全局最优便是：每次跳最优达到步数最大\n- 最后判断全局最优的结果能不能覆盖终点\n\n![55-1跳跃游戏](/img/timu/55-1.png \"跳跃游戏\")\n\n\n# 代码实现\n```Java\nclass Solution {\n    public boolean canJump(int[] nums) {\n        if (nums.length == 1) {\n            return true;\n        }\n        //覆盖范围, 初始覆盖范围应该是0，因为下面的迭代是从下标0开始的\n        int coverRange = 0;\n        //在覆盖范围内更新最大的覆盖范围\n        for (int i = 0; i <= coverRange; i++) {\n            coverRange = Math.max(coverRange, i + nums[i]);\n            //覆盖范围超过数组长度，即可达到终点，结束判断\n            if (coverRange >= nums.length - 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```\n","tags":["Java","贪心算法"],"categories":["二叉树"]},{"title":"买卖股票的最佳时机II","url":"/2024/11/29/贪心算法/买卖股票的最佳时机II/","content":"# 题目\n给定一个数组，它的第`i`个元素是一支给定股票第`i`天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1\n- 输入: [7,1,5,3,6,4]\n- 输出: 7\n- 解释: 在第2天（股票价格 = 1）的时候买入，在第3天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第4天（股票价格 = 3）的时候买入，在第5天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n\n示例2\n- 输入: [1,2,3,4,5]\n- 输出: 4\n- 解释: 在第1天（股票价格 = 1）的时候买入，在第5天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第1天和第2天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n\n示例3\n- 输入: [7,6,4,3,1]\n- 输出: 0\n- 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1ev4y1C7na/)\n\n> [力扣题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)\n\n# 思路\n- 首先，我们手上只能有一支股票，根据题目可知，要想产生利润，必须得是前一天股票的价值小于第二天的，这样我们的差值才会大于`0`。\n- 把数组分成一个个递增的小片段，当有值大于前一个值时便进行利润计算，再把一个个小片段进行累加，得到最终结果。- 只要有利润，我们就要，这便是`局部最优`，把每个小利润加起来得到的最大值，便是`全局最优`。\n\n# 代码实现\n```Java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        //作为返回值，统计结果\n        int result = 0;\n        for (int i = 1; i < prices.length; i++) {\n            //当前股票值高于前一天，即差值大于0，则加入利润中\n            result += Math.max(prices[i] - prices[i - 1], 0);\n        }\n        return result;\n    }\n}\n```","tags":["Java","贪心算法"],"categories":["贪心算法"]},{"title":"最大子序和","url":"/2024/11/29/贪心算法/最大子序和/","content":"\n# 题目\n给定一个整数数组`nums`，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例1\n- 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n- 输出：6\n- 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n示例2\n- 输入：nums = [1]\n- 输出：1\n\n示例3\n输入：nums = [5,4,-1,7,8]\n输出：23\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1aY4y1Z7ya/)\n> [力扣题目链接](https://leetcode.cn/problems/maximum-subarray/description/)\n\n# 思路\n## 暴力解法\n- 暴力解法的思路，第一层`for`就是设置起始位置，第二层 `for`循环遍历数组寻找最大值\n```Java\nclass Solution{\n    public int maxSubArray(int[] nums){\n        //先将结果设为最小整数，以便于后续结果做对比不被影响\n        int res = Integer.MIN_VALUE;\n        //单个子序列的总和\n        int count = 0;\n        for(int i = 0; i < nums.length; i++){\n            //每次进行新一轮遍历时，都重置子序列和\n            count = 0;\n            for(int j = i; j < nums,length; j++){\n                //固定外层nums[i]移动j指针，寻找最大子序列和\n                count += nums[j];\n                //当前子序列和大于res时，将其count值赋给res\n                res = count > res ? count : res;\n            }\n        }\n        return res;\n    }\n}\n\n```\n\n> 注：此方法的时间复杂度为`O(n^2)`，空间复杂度为`O(1)`，一般会超过题目给定的时间限制，提示超时错误\n\n## 贪心算法\n所谓贪心算法，就是在子序和为负数时，直接舍弃当前`count`，对其`count`进行重新赋值`0`的操作，因为负数只会拉低综合，这便是局部最优。\n\n**从代码角度上来讲：遍历`nums`，从头开始用`count`累积，如果`count`一旦加上`nums[i]`变为负数，那么就应该从`nums[i+1]`开始从`0`累积`count`了，因为已经变为负数的`count`，只会拖累总和。**\n\n- **注：这相当于是暴力解法中的不断调整最大子序和区间的起始位置。**\n\n### 代码实现\n```Java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        //当长度为1时直接返回其值便是最大子序和\n        if (nums.length == 1){\n            return nums[0];\n        }\n        //将返回值初始为整型最小值，以便后续赋值\n        int max = Integer.MIN_VALUE;\n        int count = 0;\n        for (int i = 0; i < nums.length; i++){\n            count += nums[i];\n            //先对比取出最大值，再判断count是否<0，这么做是为了防止最大值便是负数导致遗漏\n            max = Math.max(max, count); \n            // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和\n            if (count <= 0){\n                count = 0; \n            }\n        }\n       return max;\n    }\n}\n```","tags":["Java","贪心算法"],"categories":["贪心算法"]},{"title":"摆动序列","url":"/2024/11/28/贪心算法/摆动序列/","content":"# 题目\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。\n\n给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n\n例如，`[1,7,4,9,2,5]`是一个摆动序列，因为差值 `(6,-3,5,-7,3) `是正负交替出现的。相反, `[1,4,7,2,5]` 和`[1,7,4,5,5]`不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n示例1\n- 输入: [1,7,4,9,2,5]\n- 输出: 6\n- 解释: 整个序列均为摆动序列。\n\n示例2\n- 输入: [1,17,5,10,13,15,10,5,16,8]\n- 输出: 7\n- 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。\n\n示例3\n- 输入: [1,2,3,4,5,6,7,8,9]\n- 输出: 2\n\n[《代码随想录》算法公开课](https://www.bilibili.com/video/BV17M411b7NS/)\n[力扣题目链接](https://leetcode.cn/problems/wiggle-subsequence/description/)\n\n# 思路\n## 题意分析\n> 首先，题目需要的是摆动序列，即先将数列进行列出，如下图\n![376摆动序列](/img/timu/376-1.jpg \"摆动序列\")\n![376-1摆动序列](/img/timu/376-2.jpg \"摆动序列\")\n> 摆动序列即数列列出的形状如同波浪线一般，在该题中我们可以删去某些元素再进行排序，由贪心算法的每次取局部最优，得到全局最优，我们每次都只取峰值元素，即当有片段单调递增或单调递减时，我们支取最高点或者最低点。\n如示例2：\n![376-2摆动序列](/img/timu/376-3.png \"摆动序列\")\n> - **局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。**\n> - **整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。** \n\n## 注意\n1. 上下坡中有平坡\n例如：[1,2,2,2,1]\n![摆动序列](/img/timu/376-4.png \"摆动序列\")\n- 当我们遇到平波时，相同的元素支取一次就行了，此时同一一下规则，删除左边的相同元素，即`(prediff >= 0 && curdiff < 0 ) || (prediff <= 0 && curdiff > 0)`。\n> 注：`curdiff`为当前元素与前一元素的差值，`prediff`为前一元素与其前一元素的差值。\n2. 数组首尾两端\n- 对于这种特殊情况我们可以定死规则，即当数组大小为2时，`nums[0] != nums[1]`即返回2\n3. 单调坡中有平坡\n例如：[1,2,2,2,3,4]\n![摆动序列](/img/timu/376-5.png \"摆动序列\")\n- 对于这种情况我们只需要规定`prediff`的更新时间即可，即当有坡度变化时才去更新`prediff`的值。\n\n## 代码实现\n```Java\nclass Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length <= 1) {\n            return nums.length;\n        }\n        //长度为2，且元素不相等时，为摆动序列，直接返回2\n        if(nums.length == 2 && (nums[0] != nums[1]))return 2;\n        //当前差值\n        int curDiff = 0;\n        //上一个差值\n        int preDiff = 0;\n        //记录返回值，即摆动序列长度，从索引1处开始，则至少有一个数满足题意\n        int count = 1;\n        for (int i = 1; i < nums.length; i++) {\n            //得到当前差值\n            curDiff = nums[i] - nums[i - 1];\n            //如果当前差值和上一个差值为一正一负\n            //等于0的情况表示初始时的preDiff\n            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {\n                count++;\n                preDiff = curDiff;\n            }\n        }\n        return count;\n    }\n}\n```","tags":["Java","贪心算法"],"categories":["贪心算法"]},{"title":"贪心算法-分发饼干","url":"/2024/11/28/贪心算法/贪心算法-分发饼干/","content":"\n# 什么是贪心算法\n- 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n- 例如有一堆不同数额的钞票，每次只能拿一张，怎么拿能取得最大数额的钞票。\n    - 方法：将钞票从大到小进行排序，每次都拿走当前堆里最大面额的钞票，即可在指定拿取次数中获得最大数额的钞票。\n    - 例如：[100, 100, 50, 20, 50, 1, 10]\n        - 排序后为：[100, 100, 50, 50, 20, 10, 1]\n        - 依次取数组中的最大值进行累加\n        - 取完指定次数后，累加值即为最优解\n    - 在这个过程中，每次取最大面额的钞票为`局部最优`，通过每次获得`局部最优`得到的结果即为`全局最优`。\n> 注意：贪心算法并没有固定套路，也没有固定策略，贪心算法有时候就是常识的推导，所以认为本应该这么做！\n\n# 小题一道-分发饼干\n## 题目\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n\n对每个孩子`i`，都有一个胃口值`g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干`j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干`j` 分配给孩子`i`，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n> 示例1\n> - 输入: g = [1,2,3], s = [1,1]\n> - 输出: 1 \n> - 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。\n\n> 示例2\n> - 输入: g = [1,2], s = [1,2,3]\n> - 输出: 2\n> - 解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.\n\n[《代码随想录》算法公开课](https://www.bilibili.com/video/BV1MM411b7cq/)\n\n[力扣题目链接](https://leetcode.cn/problems/assign-cookies/description/)\n\n## 思路\n- 首先，每个孩子只能获得一块饼干，大尺寸的饼干能满足对于饼干需求小于等于该尺寸的孩子\n- 为了减少饼干的浪费，这里我们优先考虑将大尺寸的饼干给到胃口大的孩子\n- 即此处的`局部最优`便是，将大尺寸的饼干分给胃口大的孩子，`全局最优`便是尽量喂饱更多孩子\n![分发饼干-代码随想录](/img/timu/455-1.png \"分发饼干\")\n\n# 代码实现\n## 优先考虑胃口，先喂饱大胃口的孩子\n```Java\nclass Solution {\n    //优先考虑胃口，先喂饱大胃口\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);//对两个数组进行升序排序\n        Arrays.sort(s);\n        //count统计被喂饱的孩子\n        int count = 0;\n        //饼干尺寸从大到小进行与孩子胃口匹配\n        int start = s.length - 1;\n        // 遍历胃口\n        for (int index = g.length - 1; index >= 0; index--) {\n            //start >= 0为了防止数组越界错误\n            //当饼干尺寸满足孩子时，将饼干分给g[index],然后饼干向更小的尺寸移动，孩子也向胃口更小的移动，如果孩子胃口大于饼干尺寸，则无法满足该孩子，直接向胃口小的孩子移动\n            if(start >= 0 && g[index] <= s[start]) {\n                start--;\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n## 优先考虑饼干，小饼干先喂饱小胃口\n```Java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int start = 0;\n        int count = 0;\n        for (int i = 0; i < s.length && start < g.length; i++) {\n            if (s[i] >= g[start]) {\n                start++;\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n","tags":["Java","贪心算法"],"categories":["贪心算法"]},{"title":"修剪二叉搜索树","url":"/2024/11/27/二叉树/修剪二叉搜索树/","content":"# 题目\n给定一个二叉搜索树，同时给定最小边界`low`和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中`(high>=low)` 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。\n> 示例1\n> - 输入：root = [1,0,2], low = 1, high = 2\n> - 输出：[1,null,2]\n> ![修剪二叉树](/img/timu/669-1.jpg \"修剪二叉搜索树\") \n\n> 示例2\n> - 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n> - 输出：[3,2,null,1]\n> ![修剪二叉树](/img/timu/669-2.jpg \"修剪二叉搜索树\") \n\n[《代码随想录》算法视频公开课](https://www.bilibili.com/video/BV17P41177ud/?share_source=copy_web&vd_source=fd148478f48deef97bac8ef404e7216f)\n\n[力扣题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)\n\n# 思路\n- 题目所给二叉树为搜索二叉树\n- 首先判断根结点是否在给定范围内，如果大于给定范围，则返回其根结点的左结点作为输出树的根结点，如果小于给定范围，则返回根结点的右结点作为根结点\n- 记录当前根结点，先向左树进行遍历剪切\n- 再次记录根结点，向右树进行遍历剪切\n\n# 代码实现\n## 迭代法\n```Java\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if(root == null) return root;\n        //首先对根结点进行判断--是否超越给定边界\n        while(root != null && (root.val < low || root.val > high)){\n            //小于则返回根结点的右结点作为边界\n            if(root.val < low) root = root.right;\n            //反则返回根结点的左结点\n            else root = root.left;\n        }\n        //记录当前根结点，用于下述的遍历\n        TreeNode cur  = root;\n        //遍历左树，寻找是否有需要剪切的结点\n        while(cur != null){\n            while(cur.left != null && cur.left.val < low){\n                //进行剪切操作，因为当cur.left.val小于边界时，其左子树全部小于，直接全切了，右树同样操作\n                cur.left = cur.left.right;\n            }\n            cur = cur.left;\n        }\n        cur = root;\n        while(cur != null){\n            while(cur.right != null && cur.right.val > high){\n                cur.right = cur.right.left;\n            }\n            cur = cur.right;\n        }\n\n        return root;\n        \n    }\n}\n```","tags":["二叉树","Java","搜索二叉树"],"categories":["二叉树"]},{"title":"删除二叉搜索树中的节点","url":"/2024/11/27/二叉树/删除二叉搜索树中的节点/","content":"# 题目\n给定一个二叉搜索树的根节点`root`和一个值`key`，删除二叉搜索树中的`key`对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n[《代码随想录》算法视频公开课](https://www.bilibili.com/video/BV1tP41177us/?share_source=copy_web&vd_source=fd148478f48deef97bac8ef404e7216f)\n\n[力扣题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/description/)\n\n> 示例1\n> - 输入：root = [5,3,6,2,4,null,7], key = 3\n> - 输出：[5,4,6,2,null,null,7]\n> - 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它\n图示\n![删除二叉搜索树中的节点](/img/timu/www.jpg \"力扣450-删除二叉搜索树中的节点\")\n> 示例2\n> - 输入: root = [5,3,6,2,4,null,7], key = 0\n> - 输出: [5,3,6,2,4,null,7]\n> - 解释: 二叉树不包含值为 0 的节点\n示例3\n> - 输入: root = [], key = 0\n> - 输出: []\n\n\n\n\n# 思路\n## 删除结点可能出现的五种情况\n1. 没有找到`key`对应结点：\n    - 没找到删除的节点，遍历到空节点直接返回了\n2. 找到`key`对应的结点：\n    - `key`对应结点的左孩子为`null`，右孩子不为`null`，则直接返回右孩子\n    - `key`对应结点的右孩子为`null`，左孩子不为`null`，则直接返回左孩子\n    - 删除结点的右孩子为`null`，左孩子不为`null`，删除结点，左孩子补位，返回左孩子为根结点\n    - 删除结点的左右孩子结点都不为空，则将删除结点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。\n\n> 注意：因为该题所提供的二叉树为搜索二叉树，即删除结点的左子树值皆小于右子树的值，即可将待删结点的左子树置于待删结点的右子树的左叶子结点下。\n\n![450.删除二叉搜索树中的节点](/img/timu/450.删除二叉搜索树中的节点.gif \"450.删除二叉搜索树中的节点\")\n\n# 代码实现\n```Java\nclass Solution {\n  public TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null) return root;\n    //当遍历到的结点值为待删结点时\n    if (root.val == key) {\n      if (root.left == null) {//待删结点的左结点为空，则返回右结点\n        return root.right;\n      } else if (root.right == null) {//待删结点的右结点为空，则返回左结点\n        return root.left;\n      } else {\n        //存储待删结点的右子树头结点\n        TreeNode cur = root.right;\n        while (cur.left != null) {//找到待删结点的左叶子结点，作为待删结点左子树的挂载点\n          cur = cur.left;\n        }\n        cur.left = root.left;//挂载待删结点的左子树到待删结点的右子树的左叶子结点下\n        root = root.right;//删除待删结点\n        return root;\n      }\n    }\n    if (root.val > key) root.left = deleteNode(root.left, key);//当key小于当前结点值时向左树寻找\n    if (root.val < key) root.right = deleteNode(root.right, key);//当key大于当前结点时向右树寻找\n    return root;//仍然为传入的root\n  }\n}\n```\n\n\n\n","tags":["二叉树","Java","搜索二叉树"],"categories":["二叉树"]},{"title":"二叉搜索树中的插入操作","url":"/2024/11/26/二叉树/二叉搜索树中的插入操作/","content":"# 题目\n给定二叉搜索树[BST](https://blog.csdn.net/weixin_41811314/article/details/107104079)的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 \n输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。\n\n示例1\n> - 输入：root = [40,20,60,10,30,50,70], val = 25\n> - 输出：[40,20,60,10,30,50,70,null,null,25]\n\n示例2\n> - 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n> - 输出：[4,2,7,1,3,5]\n\n![二叉搜索树中的插入操作](/img/timu/insertbst.jpg \"力扣701-二叉搜索树中的插入操作\")\n\n## 提示\n- 给定的树上的节点数介于 0 和 10^4 之间\n- 每个节点都有一个唯一整数值，取值范围从 0 到 10^8\n- -10^8 <= val <= 10^8\n- 新值和原始二叉搜索树中的任意节点值都不同\n\n> [力扣题目链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1Et4y1c78Y/?share_source=copy_web&vd_source=fd148478f48deef97bac8ef404e7216f)\n\n---\n\n# 思路\n> 首先添加结点的位置为叶子结点（不考虑替换中间结点再构建树）。\n> 再来考虑截至条件-当遍历到该结点的子节点都为null时即找到了挂载点。\n> 根据搜索二叉树的特点，即当`val`大于`root`结点值时，向右树寻找，当`val`小于`root`结点的值时，向左树寻找。\n> 又因为该题提供的二叉树为搜索二叉树，当找到挂载点是，只需判断该值是否大于`pre`（为循环条件中存储的挂载点）。\n\n## 迭代法\n```Java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) return new TreeNode(val);//当roo为空时，用val值构建结点返回作为头结点\n        TreeNode newRoot = root;//提前存储头结点，作为返回\n        TreeNode pre = root;//存储用于挂载的结点\n        while (root != null) {\n            pre = root;\n            if (root.val > val) {//向左树寻找\n                root = root.left;\n            } else if (root.val < val) {//向右树寻找\n                root = root.right;\n            } \n        }\n        //与pre做大小比较，最后将val构造的结点挂在树下\n        if (pre.val > val) {\n            pre.left = new TreeNode(val);\n        } else {\n            pre.right = new TreeNode(val);\n        }\n\n        return newRoot;\n    }\n}\n```\n\n## 递归法\n```Java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) // 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。\n            return new TreeNode(val);\n            \n        if (root.val < val){\n            root.right = insertIntoBST(root.right, val); // 递归创建右子树\n        }else if (root.val > val){\n            root.left = insertIntoBST(root.left, val); // 递归创建左子树\n        }\n        return root;\n    }\n}\n```\n\n","tags":["二叉树","Java","搜索二叉树"],"categories":["二叉树"]},{"title":"第一个Java程序","url":"/2024/11/26/其他/第一个Java程序/","content":"# Java简介\n\n## 描述\n`Java`是一门`面向对象`的编程语言，不仅吸收了`C++`语言的各种优点，还摒弃了C++里难以理解的`多继承`、`指针`等概念。  \n\n因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。\n\n## 特性\n- 简单性、分布式、健壮性、安全性、平台独立\n- 可移植性、多线程、动态性\n\n## Java的用途\n- 桌面应用程序\n- Web应用程序\n- 分布式系统\n- 嵌入式系统应用程序\n\n## Java的发展历程\n> Java最初由`Sum`公司于1991年开发，最初命名为`Oak`\n> 后由于名字已被他人使用，将其改为`Java`并于1995年正式发布\n> 后Sum公司于2010年被Oracle公司收购，之后Java便由`Oracle`公司负责维护和版本升级\n\n---\n\n# 正题步入-第一个Java程序\n- 代码展示:\n``` Java main方法\npublic class Hello{\n    public static void main(String[] args){\n        System.out.println(\"Hello world!\");\n    }\n}\n```\n\n\n\n\n\n\n","tags":["Java","新手教程"],"categories":["Java"]}]