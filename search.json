[{"title":"删除二叉搜索树中的节点","url":"/2024/11/27/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定一个二叉搜索树的根节点<code>root</code>和一个值<code>key</code>，删除二叉搜索树中的<code>key</code>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1tP41177us/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法视频公开课</a></p>\n<p><a href=\"https://leetcode.cn/problems/delete-node-in-a-bst/description/\">力扣题目链接</a></p>\n<blockquote>\n<p>示例1</p>\n<ul>\n<li>输入：root = [5,3,6,2,4,null,7], key = 3</li>\n<li>输出：[5,4,6,2,null,null,7]</li>\n<li>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它<br />\n图示<br />\n<img src=\"/img/timu/www.jpg\" alt=\"删除二叉搜索树中的节点\" title=\"力扣450-删除二叉搜索树中的节点\" /><br />\n示例2</li>\n<li>输入: root = [5,3,6,2,4,null,7], key = 0</li>\n<li>输出: [5,3,6,2,4,null,7]</li>\n<li>解释: 二叉树不包含值为 0 的节点<br />\n示例3</li>\n<li>输入: root = [], key = 0</li>\n<li>输出: []</li>\n</ul>\n</blockquote>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<h2 id=\"删除结点可能出现的五种情况\"><a class=\"markdownIt-Anchor\" href=\"#删除结点可能出现的五种情况\"></a> 删除结点可能出现的五种情况</h2>\n<ol>\n<li>没有找到<code>key</code>对应结点：\n<ul>\n<li>没找到删除的节点，遍历到空节点直接返回了</li>\n</ul>\n</li>\n<li>找到<code>key</code>对应的结点：\n<ul>\n<li><code>key</code>对应结点的左孩子为<code>null</code>，右孩子不为<code>null</code>，则直接返回右孩子</li>\n<li><code>key</code>对应结点的右孩子为<code>null</code>，左孩子不为<code>null</code>，则直接返回左孩子</li>\n<li>删除结点的右孩子为<code>null</code>，左孩子不为<code>null</code>，删除结点，左孩子补位，返回左孩子为根结点</li>\n<li>删除结点的左右孩子结点都不为空，则将删除结点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>注意：因为该题所提供的二叉树为搜索二叉树，即删除结点的左子树值皆小于右子树的值，即可将待删结点的左子树置于待删结点的右子树的左叶子结点下。</p>\n</blockquote>\n<p><img src=\"/img/timu/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif\" alt=\"450.删除二叉搜索树中的节点\" title=\"450.删除二叉搜索树中的节点\" /></p>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">deleteNode</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"comment\">//当遍历到的结点值为待删结点时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.val == key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//待删结点的左结点为空，则返回右结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.right;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.right == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//待删结点的右结点为空，则返回左结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.left;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//存储待删结点的右子树头结点</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> root.right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.left != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//找到待删结点的左叶子结点，作为待删结点左子树的挂载点</span></span><br><span class=\"line\">          cur = cur.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.left = root.left;<span class=\"comment\">//挂载待删结点的左子树到待删结点的右子树的左叶子结点下</span></span><br><span class=\"line\">        root = root.right;<span class=\"comment\">//删除待删结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);<span class=\"comment\">//当key小于当前结点值时向左树寻找</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);<span class=\"comment\">//当key大于当前结点时向右树寻找</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;<span class=\"comment\">//仍然为传入的root</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["二叉树","Java","搜索二叉树"]},{"title":"二叉搜索树中的插入操作","url":"/2024/11/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定二叉搜索树<a href=\"https://blog.csdn.net/weixin_41811314/article/details/107104079\">BST</a>的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。<br />\n输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p>示例1</p>\n<blockquote>\n<ul>\n<li>输入：root = [40,20,60,10,30,50,70], val = 25</li>\n<li>输出：[40,20,60,10,30,50,70,null,null,25]</li>\n</ul>\n</blockquote>\n<p>示例2</p>\n<blockquote>\n<ul>\n<li>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</li>\n<li>输出：[4,2,7,1,3,5]</li>\n</ul>\n</blockquote>\n<p><img src=\"/img/timu/insertbst.jpg\" alt=\"二叉搜索树中的插入操作\" title=\"力扣701-二叉搜索树中的插入操作\" /></p>\n<h2 id=\"提示\"><a class=\"markdownIt-Anchor\" href=\"#提示\"></a> 提示</h2>\n<ul>\n<li>给定的树上的节点数介于 0 和 10^4 之间</li>\n<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>\n<li>-10^8 &lt;= val &lt;= 10^8</li>\n<li>新值和原始二叉搜索树中的任意节点值都不同</li>\n</ul>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/insert-into-a-binary-search-tree/\">力扣题目链接</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Et4y1c78Y/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法公开课</a></p>\n</blockquote>\n<hr />\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<blockquote>\n<p>首先添加结点的位置为叶子结点（不考虑替换中间结点再构建树）。<br />\n再来考虑截至条件-当遍历到该结点的子节点都为null时即找到了挂载点。<br />\n根据搜索二叉树的特点，即当<code>val</code>大于<code>root</code>结点值时，向右树寻找，当<code>val</code>小于<code>root</code>结点的值时，向左树寻找。<br />\n又因为该题提供的二叉树为搜索二叉树，当找到挂载点是，只需判断该值是否大于<code>pre</code>（为循环条件中存储的挂载点）。</p>\n</blockquote>\n<h2 id=\"迭代法\"><a class=\"markdownIt-Anchor\" href=\"#迭代法\"></a> 迭代法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">insertIntoBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);<span class=\"comment\">//当roo为空时，用val值构建结点返回作为头结点</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">newRoot</span> <span class=\"operator\">=</span> root;<span class=\"comment\">//提前存储头结点，作为返回</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> root;<span class=\"comment\">//存储用于挂载的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            pre = root;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.val &gt; val) &#123;<span class=\"comment\">//向左树寻找</span></span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &lt; val) &#123;<span class=\"comment\">//向右树寻找</span></span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//与pre做大小比较，最后将val构造的结点挂在树下</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pre.val &gt; val) &#123;</span><br><span class=\"line\">            pre.left = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pre.right = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> newRoot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"递归法\"><a class=\"markdownIt-Anchor\" href=\"#递归法\"></a> 递归法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">insertIntoBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"comment\">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt; val)&#123;</span><br><span class=\"line\">            root.right = insertIntoBST(root.right, val); <span class=\"comment\">// 递归创建右子树</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &gt; val)&#123;</span><br><span class=\"line\">            root.left = insertIntoBST(root.left, val); <span class=\"comment\">// 递归创建左子树</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["二叉树","Java","搜索二叉树"]},{"title":"第一个Java程序","url":"/2024/11/26/%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F/","content":"<h1 id=\"java简介\"><a class=\"markdownIt-Anchor\" href=\"#java简介\"></a> Java简介</h1>\n<h2 id=\"描述\"><a class=\"markdownIt-Anchor\" href=\"#描述\"></a> 描述</h2>\n<p><code>Java</code>是一门<code>面向对象</code>的编程语言，不仅吸收了<code>C++</code>语言的各种优点，还摒弃了C++里难以理解的<code>多继承</code>、<code>指针</code>等概念。</p>\n<p>因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p>\n<h2 id=\"特性\"><a class=\"markdownIt-Anchor\" href=\"#特性\"></a> 特性</h2>\n<ul>\n<li>简单性、分布式、健壮性、安全性、平台独立</li>\n<li>可移植性、多线程、动态性</li>\n</ul>\n<h2 id=\"java的用途\"><a class=\"markdownIt-Anchor\" href=\"#java的用途\"></a> Java的用途</h2>\n<ul>\n<li>桌面应用程序</li>\n<li>Web应用程序</li>\n<li>分布式系统</li>\n<li>嵌入式系统应用程序</li>\n</ul>\n<h2 id=\"java的发展历程\"><a class=\"markdownIt-Anchor\" href=\"#java的发展历程\"></a> Java的发展历程</h2>\n<blockquote>\n<p>Java最初由<code>Sum</code>公司于1991年开发，最初命名为<code>Oak</code><br />\n后由于名字已被他人使用，将其改为<code>Java</code>并于1995年正式发布<br />\n后Sum公司于2010年被Oracle公司收购，之后Java便由<code>Oracle</code>公司负责维护和版本升级</p>\n</blockquote>\n<hr />\n<h1 id=\"正题步入-第一个java程序\"><a class=\"markdownIt-Anchor\" href=\"#正题步入-第一个java程序\"></a> 正题步入-第一个Java程序</h1>\n<ul>\n<li>代码展示:</li>\n</ul>\n<figure class=\"highlight java\"><figcaption><span>main方法</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Hello</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Java"],"tags":["Java","新手教程"]},{"title":"修剪二叉搜索树","url":"/2024/11/27/%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"<h1 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h1>\n<p>给定一个二叉搜索树，同时给定最小边界<code>low</code>和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中<code>(high&gt;=low)</code> 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>\n<blockquote>\n<p>示例1</p>\n<ul>\n<li>输入：root = [1,0,2], low = 1, high = 2</li>\n<li>输出：[1,null,2]<br />\n<img src=\"/img/timu/669-1.jpg\" alt=\"修剪二叉树\" title=\"修剪二叉搜索树\" /></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>示例2</p>\n<ul>\n<li>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</li>\n<li>输出：[3,2,null,1]<br />\n<img src=\"/img/timu/669-2.jpg\" alt=\"修剪二叉树\" title=\"修剪二叉搜索树\" /></li>\n</ul>\n</blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV17P41177ud/?share_source=copy_web&amp;vd_source=fd148478f48deef97bac8ef404e7216f\">《代码随想录》算法视频公开课</a></p>\n<p><a href=\"https://leetcode.cn/problems/trim-a-binary-search-tree/description/\">力扣题目链接</a></p>\n<h1 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h1>\n<ul>\n<li>题目所给二叉树为搜索二叉树</li>\n<li>首先判断根结点是否在给定范围内，如果大于给定范围，则返回其根结点的左结点作为输出树的根结点，如果小于给定范围，则返回根结点的右结点作为根结点</li>\n<li>记录当前根结点，先向左树进行遍历剪切</li>\n<li>再次记录根结点，向右树进行遍历剪切</li>\n</ul>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h1>\n<h2 id=\"迭代法\"><a class=\"markdownIt-Anchor\" href=\"#迭代法\"></a> 迭代法</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">trimBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"comment\">//首先对根结点进行判断--是否超越给定边界</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root != <span class=\"literal\">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//小于则返回根结点的右结点作为边界</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root.val &lt; low) root = root.right;</span><br><span class=\"line\">            <span class=\"comment\">//反则返回根结点的左结点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> root = root.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//记录当前根结点，用于下述的遍历</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">cur</span>  <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"comment\">//遍历左树，寻找是否有需要剪切的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur.left != <span class=\"literal\">null</span> &amp;&amp; cur.left.val &lt; low)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//进行剪切操作，因为当cur.left.val小于边界时，其左子树全部小于，直接全切了，右树同样操作</span></span><br><span class=\"line\">                cur.left = cur.left.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur.right != <span class=\"literal\">null</span> &amp;&amp; cur.right.val &gt; high)&#123;</span><br><span class=\"line\">                cur.right = cur.right.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["二叉树"],"tags":["二叉树","Java","搜索二叉树"]}]