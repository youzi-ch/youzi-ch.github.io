[{"title":"贪心算法-分发饼干","url":"/2024/11/28/贪心算法-分发饼干/","content":"\n# 什么是贪心算法\n- 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n- 例如有一堆不同数额的钞票，每次只能拿一张，怎么拿能取得最大数额的钞票。\n    - 方法：将钞票从大到小进行排序，每次都拿走当前堆里最大面额的钞票，即可在指定拿取次数中获得最大数额的钞票。\n    - 例如：[100, 100, 50, 20, 50, 1, 10]\n        - 排序后为：[100, 100, 50, 50, 20, 10, 1]\n        - 依次取数组中的最大值进行累加\n        - 取完指定次数后，累加值即为最优解\n    - 在这个过程中，每次取最大面额的钞票为`局部最优`，通过每次获得`局部最优`得到的结果即为`全局最优`。\n> 注意：贪心算法并没有固定套路，也没有固定策略，贪心算法有时候就是常识的推导，所以认为本应该这么做！\n\n# 小题一道-分发饼干\n## 题目\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n\n对每个孩子`i`，都有一个胃口值`g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干`j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干`j` 分配给孩子`i`，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n> 示例1\n> - 输入: g = [1,2,3], s = [1,1]\n> - 输出: 1 \n> - 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。\n\n> 示例2\n> - 输入: g = [1,2], s = [1,2,3]\n> - 输出: 2\n> - 解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.\n\n[《代码随想录》算法公开课](https://www.bilibili.com/video/BV1MM411b7cq/)\n\n[力扣题目链接](https://leetcode.cn/problems/assign-cookies/description/)\n\n## 思路\n- 首先，每个孩子只能获得一块饼干，大尺寸的饼干能满足对于饼干需求小于等于该尺寸的孩子\n- 为了减少饼干的浪费，这里我们优先考虑将大尺寸的饼干给到胃口大的孩子\n- 即此处的`局部最优`便是，将大尺寸的饼干分给胃口大的孩子，`全局最优`便是尽量喂饱更多孩子\n![分发饼干-代码随想录](/img/timu/455-1.png \"分发饼干\")\n\n# 代码实现\n## 优先考虑胃口，先喂饱大胃口的孩子\n```Java\nclass Solution {\n    //优先考虑胃口，先喂饱大胃口\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);//对两个数组进行升序排序\n        Arrays.sort(s);\n        //count统计被喂饱的孩子\n        int count = 0;\n        //饼干尺寸从大到小进行与孩子胃口匹配\n        int start = s.length - 1;\n        // 遍历胃口\n        for (int index = g.length - 1; index >= 0; index--) {\n            //start >= 0为了防止数组越界错误\n            //当饼干尺寸满足孩子时，将饼干分给g[index],然后饼干向更小的尺寸移动，孩子也向胃口更小的移动，如果孩子胃口大于饼干尺寸，则无法满足该孩子，直接向胃口小的孩子移动\n            if(start >= 0 && g[index] <= s[start]) {\n                start--;\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n## 优先考虑饼干，小饼干先喂饱小胃口\n```Java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int start = 0;\n        int count = 0;\n        for (int i = 0; i < s.length && start < g.length; i++) {\n            if (s[i] >= g[start]) {\n                start++;\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n","tags":["Java","贪心算法"],"categories":["贪心算法"]},{"title":"修剪二叉搜索树","url":"/2024/11/27/修剪二叉搜索树/","content":"# 题目\n给定一个二叉搜索树，同时给定最小边界`low`和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中`(high>=low)` 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。\n> 示例1\n> - 输入：root = [1,0,2], low = 1, high = 2\n> - 输出：[1,null,2]\n> ![修剪二叉树](/img/timu/669-1.jpg \"修剪二叉搜索树\") \n\n> 示例2\n> - 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n> - 输出：[3,2,null,1]\n> ![修剪二叉树](/img/timu/669-2.jpg \"修剪二叉搜索树\") \n\n[《代码随想录》算法视频公开课](https://www.bilibili.com/video/BV17P41177ud/?share_source=copy_web&vd_source=fd148478f48deef97bac8ef404e7216f)\n\n[力扣题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)\n\n# 思路\n- 题目所给二叉树为搜索二叉树\n- 首先判断根结点是否在给定范围内，如果大于给定范围，则返回其根结点的左结点作为输出树的根结点，如果小于给定范围，则返回根结点的右结点作为根结点\n- 记录当前根结点，先向左树进行遍历剪切\n- 再次记录根结点，向右树进行遍历剪切\n\n# 代码实现\n## 迭代法\n```Java\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if(root == null) return root;\n        //首先对根结点进行判断--是否超越给定边界\n        while(root != null && (root.val < low || root.val > high)){\n            //小于则返回根结点的右结点作为边界\n            if(root.val < low) root = root.right;\n            //反则返回根结点的左结点\n            else root = root.left;\n        }\n        //记录当前根结点，用于下述的遍历\n        TreeNode cur  = root;\n        //遍历左树，寻找是否有需要剪切的结点\n        while(cur != null){\n            while(cur.left != null && cur.left.val < low){\n                //进行剪切操作，因为当cur.left.val小于边界时，其左子树全部小于，直接全切了，右树同样操作\n                cur.left = cur.left.right;\n            }\n            cur = cur.left;\n        }\n        cur = root;\n        while(cur != null){\n            while(cur.right != null && cur.right.val > high){\n                cur.right = cur.right.left;\n            }\n            cur = cur.right;\n        }\n\n        return root;\n        \n    }\n}\n```","tags":["二叉树","Java","搜索二叉树"],"categories":["二叉树"]},{"title":"删除二叉搜索树中的节点","url":"/2024/11/27/删除二叉搜索树中的节点/","content":"# 题目\n给定一个二叉搜索树的根节点`root`和一个值`key`，删除二叉搜索树中的`key`对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n[《代码随想录》算法视频公开课](https://www.bilibili.com/video/BV1tP41177us/?share_source=copy_web&vd_source=fd148478f48deef97bac8ef404e7216f)\n\n[力扣题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/description/)\n\n> 示例1\n> - 输入：root = [5,3,6,2,4,null,7], key = 3\n> - 输出：[5,4,6,2,null,null,7]\n> - 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它\n图示\n![删除二叉搜索树中的节点](/img/timu/www.jpg \"力扣450-删除二叉搜索树中的节点\")\n> 示例2\n> - 输入: root = [5,3,6,2,4,null,7], key = 0\n> - 输出: [5,3,6,2,4,null,7]\n> - 解释: 二叉树不包含值为 0 的节点\n示例3\n> - 输入: root = [], key = 0\n> - 输出: []\n\n\n\n\n# 思路\n## 删除结点可能出现的五种情况\n1. 没有找到`key`对应结点：\n    - 没找到删除的节点，遍历到空节点直接返回了\n2. 找到`key`对应的结点：\n    - `key`对应结点的左孩子为`null`，右孩子不为`null`，则直接返回右孩子\n    - `key`对应结点的右孩子为`null`，左孩子不为`null`，则直接返回左孩子\n    - 删除结点的右孩子为`null`，左孩子不为`null`，删除结点，左孩子补位，返回左孩子为根结点\n    - 删除结点的左右孩子结点都不为空，则将删除结点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。\n\n> 注意：因为该题所提供的二叉树为搜索二叉树，即删除结点的左子树值皆小于右子树的值，即可将待删结点的左子树置于待删结点的右子树的左叶子结点下。\n\n![450.删除二叉搜索树中的节点](/img/timu/450.删除二叉搜索树中的节点.gif \"450.删除二叉搜索树中的节点\")\n\n# 代码实现\n```Java\nclass Solution {\n  public TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null) return root;\n    //当遍历到的结点值为待删结点时\n    if (root.val == key) {\n      if (root.left == null) {//待删结点的左结点为空，则返回右结点\n        return root.right;\n      } else if (root.right == null) {//待删结点的右结点为空，则返回左结点\n        return root.left;\n      } else {\n        //存储待删结点的右子树头结点\n        TreeNode cur = root.right;\n        while (cur.left != null) {//找到待删结点的左叶子结点，作为待删结点左子树的挂载点\n          cur = cur.left;\n        }\n        cur.left = root.left;//挂载待删结点的左子树到待删结点的右子树的左叶子结点下\n        root = root.right;//删除待删结点\n        return root;\n      }\n    }\n    if (root.val > key) root.left = deleteNode(root.left, key);//当key小于当前结点值时向左树寻找\n    if (root.val < key) root.right = deleteNode(root.right, key);//当key大于当前结点时向右树寻找\n    return root;//仍然为传入的root\n  }\n}\n```\n\n\n\n","tags":["二叉树","Java","搜索二叉树"],"categories":["二叉树"]},{"title":"二叉搜索树中的插入操作","url":"/2024/11/26/二叉搜索树中的插入操作/","content":"# 题目\n给定二叉搜索树[BST](https://blog.csdn.net/weixin_41811314/article/details/107104079)的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 \n输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。\n\n示例1\n> - 输入：root = [40,20,60,10,30,50,70], val = 25\n> - 输出：[40,20,60,10,30,50,70,null,null,25]\n\n示例2\n> - 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n> - 输出：[4,2,7,1,3,5]\n\n![二叉搜索树中的插入操作](/img/timu/insertbst.jpg \"力扣701-二叉搜索树中的插入操作\")\n\n## 提示\n- 给定的树上的节点数介于 0 和 10^4 之间\n- 每个节点都有一个唯一整数值，取值范围从 0 到 10^8\n- -10^8 <= val <= 10^8\n- 新值和原始二叉搜索树中的任意节点值都不同\n\n> [力扣题目链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)\n\n> [《代码随想录》算法公开课](https://www.bilibili.com/video/BV1Et4y1c78Y/?share_source=copy_web&vd_source=fd148478f48deef97bac8ef404e7216f)\n\n---\n\n# 思路\n> 首先添加结点的位置为叶子结点（不考虑替换中间结点再构建树）。\n> 再来考虑截至条件-当遍历到该结点的子节点都为null时即找到了挂载点。\n> 根据搜索二叉树的特点，即当`val`大于`root`结点值时，向右树寻找，当`val`小于`root`结点的值时，向左树寻找。\n> 又因为该题提供的二叉树为搜索二叉树，当找到挂载点是，只需判断该值是否大于`pre`（为循环条件中存储的挂载点）。\n\n## 迭代法\n```Java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) return new TreeNode(val);//当roo为空时，用val值构建结点返回作为头结点\n        TreeNode newRoot = root;//提前存储头结点，作为返回\n        TreeNode pre = root;//存储用于挂载的结点\n        while (root != null) {\n            pre = root;\n            if (root.val > val) {//向左树寻找\n                root = root.left;\n            } else if (root.val < val) {//向右树寻找\n                root = root.right;\n            } \n        }\n        //与pre做大小比较，最后将val构造的结点挂在树下\n        if (pre.val > val) {\n            pre.left = new TreeNode(val);\n        } else {\n            pre.right = new TreeNode(val);\n        }\n\n        return newRoot;\n    }\n}\n```\n\n## 递归法\n```Java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) // 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。\n            return new TreeNode(val);\n            \n        if (root.val < val){\n            root.right = insertIntoBST(root.right, val); // 递归创建右子树\n        }else if (root.val > val){\n            root.left = insertIntoBST(root.left, val); // 递归创建左子树\n        }\n        return root;\n    }\n}\n```\n\n","tags":["二叉树","Java","搜索二叉树"],"categories":["二叉树"]},{"title":"第一个Java程序","url":"/2024/11/26/第一个Java程序/","content":"# Java简介\n\n## 描述\n`Java`是一门`面向对象`的编程语言，不仅吸收了`C++`语言的各种优点，还摒弃了C++里难以理解的`多继承`、`指针`等概念。  \n\n因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。\n\n## 特性\n- 简单性、分布式、健壮性、安全性、平台独立\n- 可移植性、多线程、动态性\n\n## Java的用途\n- 桌面应用程序\n- Web应用程序\n- 分布式系统\n- 嵌入式系统应用程序\n\n## Java的发展历程\n> Java最初由`Sum`公司于1991年开发，最初命名为`Oak`\n> 后由于名字已被他人使用，将其改为`Java`并于1995年正式发布\n> 后Sum公司于2010年被Oracle公司收购，之后Java便由`Oracle`公司负责维护和版本升级\n\n---\n\n# 正题步入-第一个Java程序\n- 代码展示:\n``` Java main方法\npublic class Hello{\n    public static void main(String[] args){\n        System.out.println(\"Hello world!\");\n    }\n}\n```\n\n\n\n\n\n\n","tags":["Java","新手教程"],"categories":["Java"]}]